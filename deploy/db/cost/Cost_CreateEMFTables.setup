-- -------------CoST Tables--------------
-- emf.pollutants
CREATE TABLE emf.pollutants
(
  id SERIAL PRIMARY KEY,
  name varchar(255) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.pollutants OWNER TO emf;
CREATE INDEX pollutant_id
  ON emf.pollutants
  USING btree
  (id);
ALTER TABLE emf.pollutants CLUSTER ON pollutant_id;
-- emf.pollutants
--
-- emf.source_groups
CREATE TABLE emf.source_groups
(
  id SERIAL PRIMARY KEY,
  name varchar(255) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.source_groups OWNER TO emf;
-- emf.source_groups
--

-- emf.control_measure_classes
CREATE TABLE emf.control_measure_classes
(
  id SERIAL PRIMARY KEY,
  name varchar(64) NOT NULL UNIQUE,
  description varchar(255)
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_classes OWNER TO emf;
CREATE INDEX control_measure_classes_id
  ON emf.control_measure_classes
  USING btree
  (id);
ALTER TABLE emf.control_measure_classes CLUSTER ON control_measure_classes_id;

-- emf.control_measure_classes

-- emf control_technologies
CREATE TABLE emf.control_technologies
(
  id SERIAL PRIMARY KEY,
  name varchar(128) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.control_technologies OWNER TO emf;
-- emf control_technologies

-- emf.control_measures
CREATE TABLE emf.control_measures
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  abbreviation varchar(10) NOT NULL UNIQUE,
  cm_class_id int4 REFERENCES emf.control_measure_classes(id),
  description text,
  device_code int4,
  equipment_life real,
  major_pollutant int4 REFERENCES emf.pollutants(id),
  control_technology int4 REFERENCES emf.control_technologies(id),
  source_group int4 REFERENCES emf.source_groups(id),
  data_souce varchar(128),
  creator int4  REFERENCES emf.users(id),
  cost_year int4,
  last_modified_time timestamp,
  lock_owner varchar(64),
  lock_date timestamp,
  date_reviewed timestamp,
  last_modified_by varchar(255) NOT NULL
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measures OWNER TO emf;
CREATE INDEX measure_id
  ON emf.control_measures
  USING btree
  (id);
ALTER TABLE emf.control_measures CLUSTER ON measure_id;
-- emf.control_measures


-- emf.control_measure_sccs
CREATE TABLE emf.control_measure_sccs
(
   id SERIAL PRIMARY KEY,
   control_measures_id  int4 NOT NULL REFERENCES emf.control_measures(id),
   name varchar(15),
   status varchar(255),
   UNIQUE(control_measures_id,name)
)
WITHOUT OIDS;
ALTER TABLE emf.control_measure_sccs OWNER TO emf;
CREATE INDEX measure_scc_measure_id
  ON emf.control_measure_sccs
  USING btree
  (control_measures_id);
CREATE INDEX measure_scc_scc
  ON emf.control_measure_sccs
  USING btree
  (name);
-- emf.control_measure_sccs

-- emf.control_measure_efficiencyrecords
CREATE TABLE emf.control_measure_efficiencyrecords
(
  id SERIAL PRIMARY KEY,
  control_measures_id int4 NOT NULL REFERENCES emf.control_measures(id),
  list_index int4,
  record_id int4,
  pollutant_id int4 NOT NULL REFERENCES emf.pollutants(id),
  existing_measure_abbr varchar(10),
  existing_dev_code int4,
  locale varchar(10),
  efficiency real,
  percent_reduction real,
  cost_year int4,
  cost_per_ton real,
  rule_effectiveness real,
  rule_penetration real,
  equation_type varchar(128),
  cap_rec_factor real,
  discount_rate real,
  detail text,
  effective_date timestamp,
  last_modified_by varchar(255) NOT NULL,
  last_modified_time timestamp NOT NULL,
  ref_yr_cost_per_ton float4,
  min_emis double precision,
  max_emis double precision,
  Cap_Ann_Ratio double precision,
  Incremental_Cost_Per_Ton double precision,
  UNIQUE (control_measures_id,pollutant_id,locale,existing_measure_abbr,effective_date, min_emis, max_emis)
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_efficiencyrecords OWNER TO emf;
CREATE INDEX effrec_min_max_emis
  ON emf.control_measure_efficiencyrecords
  USING btree
  (min_emis, max_emis);
CREATE INDEX er_locale
  ON emf.control_measure_efficiencyrecords
  USING btree
  (locale);
CREATE INDEX er_measureid
  ON emf.control_measure_efficiencyrecords
  USING btree
  (control_measures_id);
CREATE INDEX er_pollutantid
  ON emf.control_measure_efficiencyrecords
  USING btree
  (pollutant_id);  
-- emf.control_measure_efficiencyrecords

-- emf control_measure_sectors
CREATE TABLE emf.control_measure_sectors
(
  id SERIAL PRIMARY KEY,
  control_measure_id int4 NOT NULL REFERENCES emf.control_measures(id) ,
  list_index int4,
  sector_id int4 REFERENCES emf.sectors (id),
  UNIQUE (control_measure_id,sector_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_sectors OWNER TO emf;
-- emf control_measure_sectors

-- emf.strategy_types
CREATE TABLE emf.strategy_types
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  description text NOT NULL,
  default_sortorder text NULL DEFAULT '',
  strategy_classname varchar(255),
  lock_owner varchar(255),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_types OWNER TO emf;
-- emf.strategy_types


-- emf.control_strategies
CREATE TABLE emf.control_strategies
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  description text,
  run_status varchar(255),
  region_id int4 REFERENCES emf.regions(id),
  project_id int4 REFERENCES emf.projects (id),
  discount_rate real,
  total_cost real,
  reduction real,
  cost_year int4,
  analysis_year int4,
  creator_id int4 REFERENCES emf.users(id),
  last_modified_date timestamp,
  start_date timestamp,
  completion_date timestamp,
  strategy_type_id int4 REFERENCES emf.strategy_types(id),
  pollutant_id int4 REFERENCES emf.pollutants(id),
  filter varchar(255),
  lock_owner varchar(255),
  lock_date timestamp,
  county_file character varying,
  use_cost_equations boolean
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategies OWNER TO emf;
CREATE INDEX control_strategies_id
  ON emf.control_strategies
  USING btree
  (id);
ALTER TABLE emf.control_strategies CLUSTER ON control_strategies_id;
-- emf.control_strategies

-- emf.control_strategy_classes
CREATE TABLE emf.control_strategy_classes
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id) ,
  control_measure_class_id int4 REFERENCES emf.control_measure_classes (id),
  list_index int4,
  UNIQUE (control_strategy_id,control_measure_class_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_classes OWNER TO emf;
CREATE INDEX control_strategy_classes_measure_class_id
  ON emf.control_strategy_classes
  USING btree
  (control_measure_class_id);

CREATE INDEX control_strategy_classes_strategy_id
  ON emf.control_strategy_classes
  USING btree
  (control_strategy_id);
-- emf.control_strategy_classes

-- emf.control_strategy_measures
CREATE TABLE emf.control_strategy_measures
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id) ,
  control_measure_id int4 NOT NULL REFERENCES emf.control_measures (id),
  list_index int4 NOT NULL,
  include bool NOT NULL DEFAULT true,
  rule_effectiveness double precision,
  rule_penetration double precision,
  apply_order double precision,
  region_dataset_id integer,
  region_dataset_version integer,
  UNIQUE (control_strategy_id,control_measure_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_measures OWNER TO emf;
CREATE INDEX control_strategy_measures_apply_order
  ON emf.control_strategy_measures
  USING btree
  (apply_order);
CREATE INDEX control_strategy_strategy_measure_id
  ON emf.control_strategy_measures
  USING btree
  (control_strategy_id, control_measure_id);
ALTER TABLE emf.control_strategy_measures CLUSTER ON control_strategy_strategy_measure_id;
-- emf.control_strategy_measures

-- emf.input_datasets_control_strategies
CREATE TABLE emf.input_datasets_control_strategies
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id),
  list_index int4,
  dataset_id int4 REFERENCES emf.datasets (id),
  dataset_version integer
) 
WITHOUT OIDS;
ALTER TABLE emf.input_datasets_control_strategies OWNER TO emf;
CREATE INDEX input_datasets_control_strategies_dataset_id
  ON emf.input_datasets_control_strategies
  USING btree
  (dataset_id);

CREATE INDEX input_datasets_control_strategies_strat_id
  ON emf.input_datasets_control_strategies
  USING btree
  (control_strategy_id);
-- emf.datasets_control_strategies

-- emf.strategy_result_types
CREATE TABLE emf.strategy_result_types
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_result_types OWNER TO emf;
-- emf.strategy_result_types

-- emf.strategy_results
CREATE TABLE emf.strategy_results
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id),
  dataset_id int4 NOT NULL REFERENCES emf.datasets(id),
  strategy_result_type_id int4 NOT NULL REFERENCES emf.strategy_result_types(id),
  detailed_result_dataset_id int4 NOT NULL REFERENCES emf.datasets(id),
  controlled_inven_dataset_id int4 REFERENCES emf.datasets(id),
  list_index int4,
  total_cost real,
  total_reduction real,
  start_time timestamp,
  completion_time timestamp,
  run_status VARCHAR(255),
  record_count integer,
  UNIQUE (control_strategy_id,dataset_id,detailed_result_dataset_id)
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_results OWNER TO emf;
CREATE INDEX strategy_results_strat_id
  ON emf.strategy_results
  USING btree
  (control_strategy_id);
-- emf.strategy_results

-- emf.aggregrated_efficiencyrecords
CREATE TABLE emf.aggregrated_efficiencyrecords
(
  control_measures_id integer NOT NULL,
  pollutant_id integer NOT NULL,
  max_efficiency real,
  min_efficiency real,
  avg_efficiency real,
  max_cost_per_ton real,
  min_cost_per_ton real,
  avg_cost_per_ton real,
  avg_rule_effectiveness real,
  avg_rule_penetration real,
  CONSTRAINT aggregrated_efficiencyrecords_pkey PRIMARY KEY (control_measures_id,pollutant_id),
  CONSTRAINT aggregrated_efficiencyrecords_control_measures_id_fkey FOREIGN KEY (control_measures_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT aggregrated_efficiencyrecords_pollutant_id_fkey FOREIGN KEY (pollutant_id)
      REFERENCES emf.pollutants (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.aggregrated_efficiencyrecords OWNER TO emf;
CREATE INDEX aggeffrec_measureid
  ON emf.aggregrated_efficiencyrecords
  USING btree
  (control_measures_id);
CREATE INDEX aggeffrec_pollid
  ON emf.aggregrated_efficiencyrecords
  USING btree
  (pollutant_id);

-- add new table control_strategy_constraints...
CREATE TABLE emf.control_strategy_constraints
(
  control_strategy_id integer NOT NULL,
  max_emis_reduction real,
  max_control_efficiency real,
  min_cost_per_ton real,
  min_ann_cost real,
  CONSTRAINT control_strategy_constraints_pkey PRIMARY KEY (control_strategy_id),
  CONSTRAINT control_strategy_constraints_control_strategy_id_fkey FOREIGN KEY (control_strategy_id)
      REFERENCES emf.control_strategies (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_constraints OWNER TO emf;

CREATE INDEX constraint_strategy_id
  ON emf.control_strategy_constraints
  USING btree
  (control_strategy_id);

CREATE TABLE emf.equation_types
(
  id serial NOT NULL,
  name character varying(255) NOT NULL,
  description text NOT NULL DEFAULT ''::text,
  CONSTRAINT equation_types_pkey PRIMARY KEY (id),
  CONSTRAINT equation_types_name_key UNIQUE (name)
) 
WITHOUT OIDS;
ALTER TABLE emf.equation_types OWNER TO emf;

CREATE TABLE emf.equation_type_variables
(
  id serial NOT NULL,
  equation_type_id integer NOT NULL,
  name character varying(255) NOT NULL,
  file_col_position smallint,
  description character varying(50) DEFAULT ''::character varying,
  list_index integer,
  CONSTRAINT equation_type_variables_pkey PRIMARY KEY (id),
  CONSTRAINT equation_type_variables_equation_type_id_fkey FOREIGN KEY (equation_type_id)
      REFERENCES emf.equation_types (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT equation_type_variables_id_key UNIQUE (id, equation_type_id)
) 
WITHOUT OIDS;
ALTER TABLE emf.equation_type_variables OWNER TO emf;

CREATE TABLE emf.control_measure_equations
(
  id serial NOT NULL,
  control_measure_id integer NOT NULL,
  equation_type_id integer NOT NULL,
  equation_type_variable_id integer,
  value double precision,
  list_index integer NOT NULL,
  CONSTRAINT control_measure_equations_pkey PRIMARY KEY (id),
  CONSTRAINT control_measure_equations_control_measure_id_fkey FOREIGN KEY (control_measure_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_equations_equation_type_id_fkey FOREIGN KEY (equation_type_id, equation_type_variable_id)
      REFERENCES emf.equation_type_variables (equation_type_id, id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_equations_equation_type_id_fkey1 FOREIGN KEY (equation_type_id)
      REFERENCES emf.equation_types (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_equations OWNER TO emf;

CREATE INDEX fki_
  ON emf.control_measure_equations
  USING btree
  (equation_type_id, equation_type_variable_id);

CREATE INDEX fki_equation_measure
  ON emf.control_measure_equations
  USING btree
  (control_measure_id);

-- 9/12/2007 - DCD add user-defined functionm and aggreagte function to help build a comma-delimted list from a set
create function public.join_with_ampersand(text,text)
  returns text
  immutable strict language 'sql'
  as 'select $1||''&''||$2'
;
ALTER function public.join_with_ampersand(text,text) OWNER TO emf;

create aggregate public.concatenate_with_ampersand (
  sfunc = join_with_ampersand,
  basetype = text,
  stype = text
);
ALTER aggregate public.concatenate_with_ampersand(text) OWNER TO emf;

CREATE TABLE emf.control_measure_months
(
  id SERIAL PRIMARY KEY,
  control_measure_id integer NOT NULL,
  list_index integer,
  "month" smallint,
  CONSTRAINT control_measure_months_control_measure_id_fkey FOREIGN KEY (control_measure_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_months_control_measure_id_key UNIQUE (control_measure_id, "month")
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_months OWNER TO emf;

CREATE INDEX control_measure_months_measure_id
  ON emf.control_measure_months
  USING btree
  (control_measure_id);

CREATE INDEX control_measure_months_month
  ON emf.control_measure_months
  USING btree
  ("month");

CREATE OR REPLACE FUNCTION public.get_dataset_month(dataset_id integer) RETURNS smallint AS $$
DECLARE
	dataset_name varchar(255) := '';
	dataset_month smallint := 0;
	start_year smallint := null;
	start_month smallint := null;
	stop_year smallint := null;
	stop_month smallint := null;
BEGIN

	-- get the dataset information
	select lower(ds.name),
		EXTRACT(YEAR FROM ds.start_date_time),
		EXTRACT(MONTH FROM ds.start_date_time),
		EXTRACT(YEAR FROM ds.stop_date_time),
		EXTRACT(MONTH FROM ds.stop_date_time)
	from emf.datasets ds
	where ds.id = dataset_id
	into dataset_name,
		start_year,
		start_month,
		stop_year,
		stop_month;

	-- look at the start and stop time...
	IF start_month = stop_month and start_year = stop_year THEN
		dataset_month := start_month;
	-- look at the name to see if there is a date in it...
	ELSE
		IF position('jan' in dataset_name) > 0 or position('january' in dataset_name) > 0 THEN
			dataset_month := 1;
		ELSIF position('feb' in dataset_name) > 0 or position('february' in dataset_name) > 0 THEN
			dataset_month := 2;
		ELSIF position('mar' in dataset_name) > 0 or position('march' in dataset_name) > 0 THEN
			dataset_month := 3;
		ELSIF position('apr' in dataset_name) > 0 or position('april' in dataset_name) > 0 THEN
			dataset_month := 4;
		ELSIF position('may' in dataset_name) > 0 THEN
			dataset_month := 5;
		ELSIF position('jun' in dataset_name) > 0 or position('june' in dataset_name) > 0 THEN
			dataset_month := 6;
		ELSIF position('jul' in dataset_name) > 0 or position('july' in dataset_name) > 0 THEN
			dataset_month := 7;
		ELSIF position('aug' in dataset_name) > 0 or position('august' in dataset_name) > 0 THEN
			dataset_month := 8;
		ELSIF position('sep' in dataset_name) > 0 or position('september' in dataset_name) > 0 THEN
			dataset_month := 9;
		ELSIF position('oct' in dataset_name) > 0 or position('october' in dataset_name) > 0 THEN
			dataset_month := 10;
		ELSIF position('nov' in dataset_name) > 0 or position('november' in dataset_name) > 0 THEN
			dataset_month := 11;
		ELSIF position('dec' in dataset_name) > 0 or position('december' in dataset_name) > 0 THEN
			dataset_month := 12;
		END IF;
	END IF;

	-- return Zero if no month was found
	RETURN dataset_month;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.multiply(double precision, double precision)
  RETURNS double precision AS
'select $1 * $2'
  LANGUAGE 'sql' IMMUTABLE STRICT;
ALTER FUNCTION public.multiply(double precision, double precision) OWNER TO emf;

CREATE AGGREGATE public.times(
  BASETYPE=float8,
  SFUNC=multiply,
  STYPE=float8
);
ALTER AGGREGATE public.times(float8) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.create_strategy_detailed_result_table_indexes(table_name character varying)
  RETURNS void AS
$BODY$
DECLARE
	index_name varchar(63) := '';
BEGIN

	-- create source_id btree index
	IF length('source_id_' || table_name) >= 63 - 10 THEN
		index_name := 'source_id_' || substr(table_name, 11, 63);
	ELSE
		index_name := 'source_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(source_id)';

	-- create record_id btree index
	IF length('record_id' || table_name) >= 63 - 10 THEN
		index_name := 'record_id_' || substr(table_name, 11, 63);
	ELSE
		index_name := 'record_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(record_id)';

	-- create fips btree index
	IF length('fips_' || table_name) >= 63 - 5 THEN
		index_name := 'fips_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'fips_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(fips)';

	-- create poll btree index
	IF length('poll_' || table_name) >= 63 - 5 THEN
		index_name := 'poll_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'poll_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(poll)';

	-- create scc btree index
	IF length('scc_' || table_name) >= 63 - 4 THEN
		index_name := 'scc_' || substr(table_name, 5, 63);
	ELSE
		index_name := 'scc_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(scc)';

	-- create cm_id btree index
	IF length('cm_id_' || table_name) >= 63 - 6 THEN
		index_name := 'cm_id_' || substr(table_name, 7, 63);
	ELSE
		index_name := 'cm_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(cm_id)';

END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION public.create_strategy_detailed_result_table_indexes(table_name character varying) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.create_orl_table_indexes(table_name character varying)
  RETURNS void AS
$BODY$
DECLARE
	index_name varchar(63) := '';
BEGIN

--select 'ds_rep_mole_alm_20021105_36km_cmaq_cb05pm_2002ac_txt_2066644752',
--	'fips_' || substr('ds_rep_mole_alm_20021105_36km_cmaq_cb05pm_2002ac_txt_2066644752', 6, 63), 
--	length('fips_' || substr('ds_rep_mole_alm_20021105_36km_cmaq_cb05pm_2002ac_txt_2066644752', 6, 63))

	-- create fips btree index
	IF length('fips_' || table_name) >= 63 - 5 THEN
		index_name := 'fips_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'fips_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(fips)';

	-- create poll btree index
	IF length('poll_' || table_name) >= 63 - 5 THEN
		index_name := 'poll_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'poll_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(poll)';

	-- create scc btree index
	IF length('scc_' || table_name) >= 63 - 4 THEN
		index_name := 'scc_' || substr(table_name, 5, 63);
	ELSE
		index_name := 'scc_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(scc)';

END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION public.create_orl_table_indexes(table_name character varying) OWNER TO emf;
