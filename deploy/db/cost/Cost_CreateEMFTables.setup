-- -------------CoST Tables--------------
-- emf.pollutants
CREATE TABLE emf.pollutants
(
  id SERIAL PRIMARY KEY,
  name varchar(255) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.pollutants OWNER TO emf;
CREATE INDEX pollutant_id
  ON emf.pollutants
  USING btree
  (id);
ALTER TABLE emf.pollutants CLUSTER ON pollutant_id;
CREATE INDEX pollutant_name
  ON emf.pollutants
  USING btree
  (name);
-- emf.pollutants
--
-- emf.source_groups
CREATE TABLE emf.source_groups
(
  id SERIAL PRIMARY KEY,
  name varchar(255) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.source_groups OWNER TO emf;
CREATE INDEX source_groups_id
  ON emf.source_groups
  USING btree
  (id);
ALTER TABLE emf.source_groups CLUSTER ON source_groups_id;
CREATE INDEX source_groups_name
  ON emf.source_groups
  USING btree
  (name);
-- emf.source_groups
--

-- emf.control_measure_classes
CREATE TABLE emf.control_measure_classes
(
  id SERIAL PRIMARY KEY,
  name varchar(64) NOT NULL UNIQUE,
  description varchar(255)
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_classes OWNER TO emf;
CREATE INDEX control_measure_classes_id
  ON emf.control_measure_classes
  USING btree
  (id);
ALTER TABLE emf.control_measure_classes CLUSTER ON control_measure_classes_id;

-- emf.control_measure_classes

-- emf control_technologies
CREATE TABLE emf.control_technologies
(
  id SERIAL PRIMARY KEY,
  name varchar(128) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.control_technologies OWNER TO emf;
CREATE INDEX control_technologies_id
  ON emf.control_technologies
  USING btree
  (id);
ALTER TABLE emf.control_technologies CLUSTER ON control_technologies_id;
CREATE INDEX control_technologies_name
  ON emf.control_technologies
  USING btree
  (name);
-- emf control_technologies

-- emf.control_measures
CREATE TABLE emf.control_measures
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  abbreviation varchar(10) NOT NULL UNIQUE,
  cm_class_id int4 REFERENCES emf.control_measure_classes(id),
  description text,
  device_code int4,
  equipment_life real,
  major_pollutant int4 REFERENCES emf.pollutants(id),
  control_technology int4 REFERENCES emf.control_technologies(id),
  source_group int4 REFERENCES emf.source_groups(id),
  data_souce varchar(128),
  creator int4  REFERENCES emf.users(id),
  cost_year int4,
  last_modified_time timestamp,
  lock_owner varchar(64),
  lock_date timestamp,
  date_reviewed timestamp,
  last_modified_by varchar(255) NOT NULL
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measures OWNER TO emf;
CREATE INDEX measure_id
  ON emf.control_measures
  USING btree
  (id);
ALTER TABLE emf.control_measures CLUSTER ON measure_id;
CREATE INDEX control_measures_control_technology
   ON emf.control_measures (control_technology);
CREATE INDEX control_measures_source_group
  ON emf.control_measures
  USING btree
  (source_group);
-- emf.control_measures


-- emf.control_measure_sccs
CREATE TABLE emf.control_measure_sccs
(
   id SERIAL PRIMARY KEY,
   control_measures_id  int4 NOT NULL REFERENCES emf.control_measures(id),
   name varchar(15),
   status varchar(255),
   UNIQUE(control_measures_id,name)
)
WITHOUT OIDS;
ALTER TABLE emf.control_measure_sccs OWNER TO emf;
CREATE INDEX measure_scc_measure_id
  ON emf.control_measure_sccs
  USING btree
  (control_measures_id);
CREATE INDEX measure_scc_scc
  ON emf.control_measure_sccs
  USING btree
  (name);
-- emf.control_measure_sccs

-- emf.control_measure_efficiencyrecords
CREATE TABLE emf.control_measure_efficiencyrecords
(
  id SERIAL PRIMARY KEY,
  control_measures_id int4 NOT NULL REFERENCES emf.control_measures(id),
  list_index int4,
  record_id int4,
  pollutant_id int4 NOT NULL REFERENCES emf.pollutants(id),
  existing_measure_abbr varchar(10),
  existing_dev_code int4,
  locale varchar(10),
  efficiency real,
  percent_reduction real,
  cost_year int4,
  cost_per_ton real,
  rule_effectiveness real,
  rule_penetration real,
  equation_type varchar(128),
  cap_rec_factor real,
  discount_rate real,
  detail text,
  effective_date timestamp,
  last_modified_by varchar(255) NOT NULL,
  last_modified_time timestamp NOT NULL,
  ref_yr_cost_per_ton float4,
  min_emis double precision,
  max_emis double precision,
  Cap_Ann_Ratio double precision,
  Incremental_Cost_Per_Ton double precision,
  UNIQUE (control_measures_id,pollutant_id,locale,existing_measure_abbr,effective_date, min_emis, max_emis)
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_efficiencyrecords OWNER TO emf;
CREATE INDEX effrec_min_max_emis
  ON emf.control_measure_efficiencyrecords
  USING btree
  (min_emis, max_emis);
CREATE INDEX er_locale
  ON emf.control_measure_efficiencyrecords
  USING btree
  (locale);
CREATE INDEX er_measureid
  ON emf.control_measure_efficiencyrecords
  USING btree
  (control_measures_id);
CREATE INDEX er_pollutantid
  ON emf.control_measure_efficiencyrecords
  USING btree
  (pollutant_id);  
-- emf.control_measure_efficiencyrecords

-- emf control_measure_sectors
CREATE TABLE emf.control_measure_sectors
(
  id SERIAL PRIMARY KEY,
  control_measure_id int4 NOT NULL REFERENCES emf.control_measures(id) ,
  list_index int4,
  sector_id int4 REFERENCES emf.sectors (id),
  UNIQUE (control_measure_id,sector_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_sectors OWNER TO emf;
CREATE INDEX control_measure_sectors_measure_id
  ON emf.control_measure_sectors
  USING btree
  (control_measure_id);  
CREATE INDEX control_measure_sectors_sector_id
  ON emf.control_measure_sectors
  USING btree
  (sector_id);  
-- emf control_measure_sectors

-- emf.strategy_types
CREATE TABLE emf.strategy_types
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  description text NOT NULL,
  default_sortorder text NULL DEFAULT '',
  strategy_classname varchar(255),
  lock_owner varchar(255),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_types OWNER TO emf;
CREATE INDEX strategy_types_id
   ON emf.strategy_types (id);
ALTER TABLE emf.strategy_types CLUSTER ON strategy_types_id;
-- emf.strategy_types


-- emf.control_strategies
CREATE TABLE emf.control_strategies
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  description text,
  run_status varchar(255),
  region_id int4 REFERENCES emf.regions(id),
  project_id int4 REFERENCES emf.projects (id),
  discount_rate real,
  total_cost real,
  reduction real,
  cost_year int4,
  analysis_year int4,
  creator_id int4 REFERENCES emf.users(id),
  last_modified_date timestamp,
  start_date timestamp,
  completion_date timestamp,
  strategy_type_id int4 REFERENCES emf.strategy_types(id),
  pollutant_id int4 REFERENCES emf.pollutants(id),
  filter varchar(255),
  lock_owner varchar(255),
  lock_date timestamp,
  county_file character varying,
  county_dataset_id int4 REFERENCES emf.datasets (id),
  county_dataset_version int4,
  use_cost_equations boolean,
  export_directory character varying,
  delete_results boolean DEFAULT true
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategies OWNER TO emf;
CREATE INDEX control_strategies_id
  ON emf.control_strategies
  USING btree
  (id);
ALTER TABLE emf.control_strategies CLUSTER ON control_strategies_id;
CREATE INDEX fki_strategy_county_dataset
  ON emf.control_strategies
  USING btree
  (county_dataset_id);
-- emf.control_strategies

-- emf.control_strategy_classes
CREATE TABLE emf.control_strategy_classes
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id) ,
  control_measure_class_id int4 REFERENCES emf.control_measure_classes (id),
  list_index int4,
  UNIQUE (control_strategy_id,control_measure_class_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_classes OWNER TO emf;
CREATE INDEX control_strategy_classes_measure_class_id
  ON emf.control_strategy_classes
  USING btree
  (control_measure_class_id);

CREATE INDEX control_strategy_classes_strategy_id
  ON emf.control_strategy_classes
  USING btree
  (control_strategy_id);
-- emf.control_strategy_classes

-- emf.control_strategy_measures
CREATE TABLE emf.control_strategy_measures
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id) ,
  control_measure_id int4 NOT NULL REFERENCES emf.control_measures (id),
  list_index int4 NOT NULL,
  include bool NOT NULL DEFAULT true,
  rule_effectiveness double precision,
  rule_penetration double precision,
  apply_order double precision,
  region_dataset_id integer,
  region_dataset_version integer,
  UNIQUE (control_strategy_id,control_measure_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_measures OWNER TO emf;
CREATE INDEX control_strategy_measures_apply_order
  ON emf.control_strategy_measures
  USING btree
  (apply_order);
CREATE INDEX control_strategy_strategy_id
  ON emf.control_strategy_measures
  USING btree
  (control_strategy_id);
CREATE INDEX control_strategy_measure_id
  ON emf.control_strategy_measures
  USING btree
  (control_measure_id);
-- emf.control_strategy_measures

-- emf.input_datasets_control_strategies
CREATE TABLE emf.input_datasets_control_strategies
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id),
  list_index int4,
  dataset_id int4 REFERENCES emf.datasets (id),
  dataset_version integer
) 
WITHOUT OIDS;
ALTER TABLE emf.input_datasets_control_strategies OWNER TO emf;
CREATE INDEX input_datasets_control_strategies_dataset_id
  ON emf.input_datasets_control_strategies
  USING btree
  (dataset_id);

CREATE INDEX input_datasets_control_strategies_strat_id
  ON emf.input_datasets_control_strategies
  USING btree
  (control_strategy_id);
-- emf.datasets_control_strategies

-- emf.strategy_result_types
CREATE TABLE emf.strategy_result_types
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_result_types OWNER TO emf;
CREATE INDEX strategy_result_types_id
  ON emf.strategy_result_types
  USING btree
  (id);
ALTER TABLE emf.strategy_result_types CLUSTER ON strategy_result_types_id;
-- emf.strategy_result_types

-- emf.strategy_results
CREATE TABLE emf.strategy_results
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id),
  dataset_id int4 NOT NULL REFERENCES emf.datasets(id),
  strategy_result_type_id int4 NOT NULL REFERENCES emf.strategy_result_types(id),
  detailed_result_dataset_id int4 REFERENCES emf.datasets(id),
  controlled_inven_dataset_id int4 REFERENCES emf.datasets(id),
  list_index int4,
  total_cost real,
  total_reduction real,
  start_time timestamp,
  completion_time timestamp,
  run_status VARCHAR(255),
  record_count integer,
  dataset_version integer NOT NULL DEFAULT 0,
  UNIQUE (control_strategy_id,dataset_id,detailed_result_dataset_id)
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_results OWNER TO emf;
CREATE INDEX strategy_results_strat_id
  ON emf.strategy_results
  USING btree
  (control_strategy_id);
-- emf.strategy_results

-- emf.aggregrated_efficiencyrecords
CREATE TABLE emf.aggregrated_efficiencyrecords
(
  control_measures_id integer NOT NULL,
  pollutant_id integer NOT NULL,
  max_efficiency real,
  min_efficiency real,
  avg_efficiency real,
  max_cost_per_ton real,
  min_cost_per_ton real,
  avg_cost_per_ton real,
  avg_rule_effectiveness real,
  avg_rule_penetration real,
  CONSTRAINT aggregrated_efficiencyrecords_pkey PRIMARY KEY (control_measures_id,pollutant_id),
  CONSTRAINT aggregrated_efficiencyrecords_control_measures_id_fkey FOREIGN KEY (control_measures_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT aggregrated_efficiencyrecords_pollutant_id_fkey FOREIGN KEY (pollutant_id)
      REFERENCES emf.pollutants (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.aggregrated_efficiencyrecords OWNER TO emf;
CREATE INDEX aggeffrec_measureid
  ON emf.aggregrated_efficiencyrecords
  USING btree
  (control_measures_id);
CREATE INDEX aggeffrec_pollid
  ON emf.aggregrated_efficiencyrecords
  USING btree
  (pollutant_id);

-- add new table control_strategy_constraints...
CREATE TABLE emf.control_strategy_constraints
(
  control_strategy_id integer NOT NULL,
  max_emis_reduction real,
  max_control_efficiency real,
  min_cost_per_ton real,
  min_ann_cost real,
  domain_wide_emis_reduction double precision,
  domain_wide_pct_reduction double precision,
  CONSTRAINT control_strategy_constraints_pkey PRIMARY KEY (control_strategy_id),
  CONSTRAINT control_strategy_constraints_control_strategy_id_fkey FOREIGN KEY (control_strategy_id)
      REFERENCES emf.control_strategies (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_constraints OWNER TO emf;

CREATE INDEX constraint_strategy_id
  ON emf.control_strategy_constraints
  USING btree
  (control_strategy_id);

CREATE TABLE emf.equation_types
(
  id serial NOT NULL,
  name character varying(255) NOT NULL,
  description text NOT NULL DEFAULT ''::text,
  CONSTRAINT equation_types_pkey PRIMARY KEY (id),
  CONSTRAINT equation_types_name_key UNIQUE (name)
) 
WITHOUT OIDS;
ALTER TABLE emf.equation_types OWNER TO emf;
CREATE INDEX equation_types_id
   ON emf.equation_types (id);
ALTER TABLE emf.equation_types CLUSTER ON equation_types_id;

CREATE TABLE emf.equation_type_variables
(
  id serial NOT NULL,
  equation_type_id integer NOT NULL,
  name character varying(255) NOT NULL,
  file_col_position smallint,
  description character varying(50) DEFAULT ''::character varying,
  list_index integer,
  CONSTRAINT equation_type_variables_pkey PRIMARY KEY (id),
  CONSTRAINT equation_type_variables_equation_type_id_fkey FOREIGN KEY (equation_type_id)
      REFERENCES emf.equation_types (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT equation_type_variables_id_key UNIQUE (id, equation_type_id)
) 
WITHOUT OIDS;
ALTER TABLE emf.equation_type_variables OWNER TO emf;
CREATE INDEX equation_type_variables_equation_type_id
  ON emf.equation_type_variables
  USING btree
  (equation_type_id);
CREATE INDEX equation_type_variables_id
  ON emf.equation_type_variables
  USING btree
  (id);
ALTER TABLE emf.equation_type_variables CLUSTER ON equation_type_variables_id;

CREATE TABLE emf.control_measure_equations
(
  id SERIAL PRIMARY KEY,
  control_measure_id integer NOT NULL,
  equation_type_id integer NOT NULL,
  pollutant_id integer NOT NULL,
  cost_year integer NOT NULL,
  value1 double precision,
  value2 double precision,
  value3 double precision,
  value4 double precision,
  value5 double precision,
  value6 double precision,
  value7 double precision,
  value8 double precision,
  value9 double precision,
  value10 double precision,
  list_index integer NOT NULL,
  UNIQUE (control_measure_id, equation_type_id, pollutant_id),
  CONSTRAINT control_measure_equations_control_measure_id_fkey FOREIGN KEY (control_measure_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_equations_pollutant_id_fkey FOREIGN KEY (pollutant_id)
      REFERENCES emf.pollutants (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_equations_equation_type_id_fkey1 FOREIGN KEY (equation_type_id)
      REFERENCES emf.equation_types (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_equations OWNER TO emf;


-- Index: emf.fki_

-- DROP INDEX emf.fki_;

CREATE INDEX control_measure_equations_equation_type_id
  ON emf.control_measure_equations
  USING btree
  (equation_type_id);

-- Index: emf.fki_equation_measure

-- DROP INDEX emf.fki_equation_measure;

CREATE INDEX control_measure_equations_meaure_id
  ON emf.control_measure_equations
  USING btree
  (control_measure_id);


CREATE INDEX control_measure_equations_pollutant_id
  ON emf.control_measure_equations
  USING btree
  (pollutant_id);

CREATE INDEX control_measure_equations_cost_year
  ON emf.control_measure_equations
  USING btree
  (cost_year);

-- 9/12/2007 - DCD add user-defined functionm and aggreagte function to help build a comma-delimted list from a set
create function public.join_with_ampersand(text,text)
  returns text
  immutable strict language 'sql'
  as 'select $1||''&''||$2'
;
ALTER function public.join_with_ampersand(text,text) OWNER TO emf;

create aggregate public.concatenate_with_ampersand (
  sfunc = join_with_ampersand,
  basetype = text,
  stype = text
);
ALTER aggregate public.concatenate_with_ampersand(text) OWNER TO emf;

CREATE TABLE emf.control_measure_months
(
  id SERIAL PRIMARY KEY,
  control_measure_id integer NOT NULL,
  list_index integer,
  "month" smallint,
  CONSTRAINT control_measure_months_control_measure_id_fkey FOREIGN KEY (control_measure_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_months_control_measure_id_key UNIQUE (control_measure_id, "month")
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_months OWNER TO emf;

CREATE INDEX control_measure_months_measure_id
  ON emf.control_measure_months
  USING btree
  (control_measure_id);

CREATE INDEX control_measure_months_month
  ON emf.control_measure_months
  USING btree
  ("month");



CREATE TABLE emf.control_strategy_target_pollutants
(
   id serial, 
   control_strategy_id integer, 
   pollutant_id integer, 
   precedence double precision, 
   list_index integer, 
   CONSTRAINT control_strategy_target_pollutants_id_pk PRIMARY KEY (id), 
   CONSTRAINT control_strategy_target_pollutants_strategy_fk FOREIGN KEY (control_strategy_id) REFERENCES emf.control_strategies (id)    ON UPDATE NO ACTION ON DELETE NO ACTION, 
   CONSTRAINT control_strategy_target_pollutants_pollutant_fk FOREIGN KEY (pollutant_id) REFERENCES emf.pollutants (id)    ON UPDATE NO ACTION ON DELETE NO ACTION, 
   CONSTRAINT control_strategy_target_pollutants_uq UNIQUE (control_strategy_id, pollutant_id)
) WITHOUT OIDS;
ALTER TABLE emf.control_strategy_target_pollutants OWNER TO emf;
CREATE INDEX control_strategy_target_pollutants_pollutant_id
  ON emf.control_strategy_target_pollutants
  USING btree
  (pollutant_id);

CREATE INDEX control_strategy_target_pollutants_precedence
  ON emf.control_strategy_target_pollutants
  USING btree
  (precedence);
  
CREATE INDEX control_strategy_target_pollutants_strategy_id
  ON emf.control_strategy_target_pollutants
  USING btree
  (control_strategy_id);


-- FUNCTIONS


CREATE OR REPLACE FUNCTION public.get_dataset_month(dataset_id integer)
  RETURNS smallint AS
$BODY$
DECLARE
	dataset_name varchar(255) := '';
	dataset_month smallint := 0;
	start_year smallint := null;
	start_month smallint := null;
	stop_year smallint := null;
	stop_month smallint := null;
BEGIN

	-- get the dataset information
	select lower(ds.name),
		EXTRACT(YEAR FROM ds.start_date_time),
		EXTRACT(MONTH FROM ds.start_date_time),
		EXTRACT(YEAR FROM ds.stop_date_time),
		EXTRACT(MONTH FROM ds.stop_date_time)
	from emf.datasets ds
	where ds.id = dataset_id
	into dataset_name,
		start_year,
		start_month,
		stop_year,
		stop_month;

	-- look at the start and stop time...
	IF start_month = stop_month and start_year = stop_year THEN
		dataset_month := start_month;
	-- look at the name to see if there is a date in it...
	ELSE
		IF position('_jan' in dataset_name) > 0 or position('_january' in dataset_name) > 0 THEN
			dataset_month := 1;
		ELSIF position('_feb' in dataset_name) > 0 or position('_february' in dataset_name) > 0 THEN
			dataset_month := 2;
		ELSIF position('_mar' in dataset_name) > 0 or position('_march' in dataset_name) > 0 THEN
			dataset_month := 3;
		ELSIF position('_apr' in dataset_name) > 0 or position('_april' in dataset_name) > 0 THEN
			dataset_month := 4;
		ELSIF position('_may' in dataset_name) > 0 THEN
			dataset_month := 5;
		ELSIF position('_jun' in dataset_name) > 0 or position('_june' in dataset_name) > 0 THEN
			dataset_month := 6;
		ELSIF position('_jul' in dataset_name) > 0 or position('_july' in dataset_name) > 0 THEN
			dataset_month := 7;
		ELSIF position('_aug' in dataset_name) > 0 or position('_august' in dataset_name) > 0 THEN
			dataset_month := 8;
		ELSIF position('_sep' in dataset_name) > 0 or position('_september' in dataset_name) > 0 THEN
			dataset_month := 9;
		ELSIF position('_oct' in dataset_name) > 0 or position('_october' in dataset_name) > 0 THEN
			dataset_month := 10;
		ELSIF position('_nov' in dataset_name) > 0 or position('_november' in dataset_name) > 0 THEN
			dataset_month := 11;
		ELSIF position('_dec' in dataset_name) > 0 or position('_december' in dataset_name) > 0 THEN
			dataset_month := 12;
		END IF;
	END IF;

	-- return Zero if no month was found
	RETURN dataset_month;
END;
$BODY$
  LANGUAGE 'plpgsql' IMMUTABLE;
ALTER FUNCTION public.get_dataset_month(dataset_id integer) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.multiply(double precision, double precision)
  RETURNS double precision AS
'select $1 * $2'
  LANGUAGE 'sql' IMMUTABLE STRICT;
ALTER FUNCTION public.multiply(double precision, double precision) OWNER TO emf;

CREATE AGGREGATE public.times(
  BASETYPE=float8,
  SFUNC=multiply,
  STYPE=float8
);
ALTER AGGREGATE public.times(float8) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.create_strategy_detailed_result_table_indexes(table_name character varying)
  RETURNS void AS
$BODY$
DECLARE
	index_name varchar(63) := '';
BEGIN

	-- create source_id btree index
	IF length('source_id_' || table_name) >= 63 - 10 THEN
		index_name := 'source_id_' || substr(table_name, 11, 63);
	ELSE
		index_name := 'source_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(source_id)';

	-- create record_id btree index
	IF length('record_id' || table_name) >= 63 - 10 THEN
		index_name := 'record_id_' || substr(table_name, 11, 63);
	ELSE
		index_name := 'record_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(record_id)';

	-- create fips btree index
	IF length('fips_' || table_name) >= 63 - 5 THEN
		index_name := 'fips_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'fips_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(fips)';

	-- create scc btree index
	IF length('scc_' || table_name) >= 63 - 4 THEN
		index_name := 'scc_' || substr(table_name, 5, 63);
	ELSE
		index_name := 'scc_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(scc)';

	-- create plantid btree index
	IF length('plantid_' || table_name) >= 63 - 8 THEN
		index_name := 'plantid_' || substr(table_name, 9, 63);
	ELSE
		index_name := 'plantid_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(plantid)';

	-- create pointid btree index
	IF length('pointid_' || table_name) >= 63 - 8 THEN
		index_name := 'pointid_' || substr(table_name, 9, 63);
	ELSE
		index_name := 'pointid_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(pointid)';

	-- create stackid btree index
	IF length('stackid_' || table_name) >= 63 - 8 THEN
		index_name := 'stackid_' || substr(table_name, 9, 63);
	ELSE
		index_name := 'stackid_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(stackid)';

	-- create segment btree index
	IF length('segment_' || table_name) >= 63 - 8 THEN
		index_name := 'segment_' || substr(table_name, 9, 63);
	ELSE
		index_name := 'segment_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(segment)';

	-- create poll btree index
	IF length('poll_' || table_name) >= 63 - 5 THEN
		index_name := 'poll_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'poll_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(poll)';

	-- create cm_id btree index
	IF length('cm_id_' || table_name) >= 63 - 6 THEN
		index_name := 'cm_id_' || substr(table_name, 7, 63);
	ELSE
		index_name := 'cm_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(cm_id)';

END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION public.create_strategy_detailed_result_table_indexes(table_name character varying) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.create_orl_table_indexes(table_name character varying)
  RETURNS void AS
$BODY$
DECLARE
	index_name varchar(63) := '';
	is_point_table boolean := false;
BEGIN

	-- see if there are point specific columns to be indexed
	SELECT count(1) = 4
	FROM pg_class c
		inner join pg_attribute a
		on a.attrelid = c.oid
		inner join pg_type t
		on t.oid = a.atttypid
	WHERE c.relname = lower(table_name)
		and a.attname in ('plantid','pointid','stackid','segment')
		AND a.attnum > 0
	into is_point_table;

	-- Create Indexes....

	-- create fips btree index
	IF length('fips_' || table_name) >= 63 - 5 THEN
		index_name := 'fips_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'fips_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(fips)';

	-- create poll btree index
	IF length('poll_' || table_name) >= 63 - 5 THEN
		index_name := 'poll_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'poll_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(poll)';

	-- create scc btree index
	IF length('scc_' || table_name) >= 63 - 4 THEN
		index_name := 'scc_' || substr(table_name, 5, 63);
	ELSE
		index_name := 'scc_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(scc)';

	-- add point specific indexes--plantid, pointid, stackid, segment
	IF is_point_table THEN
		-- create plantid btree index
		IF length('plantid_' || table_name) >= 63 - 8 THEN
			index_name := 'plantid_' || substr(table_name, 9, 63);
		ELSE
			index_name := 'plantid_' || table_name;
		END IF;
		execute 'CREATE INDEX ' || index_name || '
				ON emissions.' || table_name || '
				USING btree
				(plantid)';

		-- create pointid btree index
		IF length('pointid_' || table_name) >= 63 - 8 THEN
			index_name := 'pointid_' || substr(table_name, 9, 63);
		ELSE
			index_name := 'pointid_' || table_name;
		END IF;
		execute 'CREATE INDEX ' || index_name || '
				ON emissions.' || table_name || '
				USING btree
				(pointid)';

		-- create stackid btree index
		IF length('stackid_' || table_name) >= 63 - 8 THEN
			index_name := 'stackid_' || substr(table_name, 9, 63);
		ELSE
			index_name := 'stackid_' || table_name;
		END IF;
		execute 'CREATE INDEX ' || index_name || '
				ON emissions.' || table_name || '
				USING btree
				(stackid)';

		-- create segment btree index
		IF length('segment_' || table_name) >= 63 - 8 THEN
			index_name := 'segment_' || substr(table_name, 9, 63);
		ELSE
			index_name := 'segment_' || table_name;
		END IF;
		execute 'CREATE INDEX ' || index_name || '
				ON emissions.' || table_name || '
				USING btree
				(segment)';
	END IF;

END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION public.create_orl_table_indexes(table_name character varying) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.build_version_where_filter(dataset_id integer, version integer)
  RETURNS text AS
$BODY$
DECLARE
	path text := '';
	versions_path text := '';
	where_filter text := '';
	delete_filter text := '';
	counter integer := 1;
	version_part text := '';
BEGIN

	--get version path
	select versions.path
	from emissions.versions
	where versions.dataset_id = dataset_id
		and versions.version = version
	into path;

	-- build path into where clause
	IF path is null or length(path) = 0 THEN
		versions_path := version;
	ELSE
		versions_path := path || ',' || version;
	END IF;
	where_filter := 'version IN (' || versions_path || ') and dataset_id = ' || dataset_id;

	version_part := split_part(versions_path, ',', counter);
	WHILE length(version_part) > 0 LOOP
		IF version_part != '0' THEN
			IF length(delete_filter) > 0 THEN
				delete_filter := delete_filter || ' and delete_versions NOT SIMILAR TO ''' || '(' || version_part || '|' || version_part || ',%|%,' || version_part || ',%|%,' || version_part || ')''';
			ELSE
				delete_filter := delete_filter || 'delete_versions NOT SIMILAR TO ''' || '(' || version_part || '|' || version_part || ',%|%,' || version_part || ',%|%,' || version_part || ')''';
			END IF;
		END IF;
		counter := counter + 1;
		version_part := split_part(versions_path, ',', counter);
	END LOOP;
	IF length(delete_filter) > 0 THEN
		where_filter := where_filter || ' and ' || delete_filter;
	END IF;

	RETURN where_filter;
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION public.build_version_where_filter(dataset_id integer, version integer) OWNER TO postgres;

CREATE OR REPLACE FUNCTION public.run_apply_measures_in_series_strategy_batch_by_state(control_strategy_id integer, input_dataset_id integer, 
	inv_table_name varchar(63), inv_filter varchar, 
	detailed_result_dataset_id integer, detailed_result_table_name varchar(63), 
	strfipsst varchar(2), measures_count integer, 
	measure_classes_count integer, target_pollutant_id integer,
	measure_with_region_count integer, county_dataset_filter_sql text,
	min_emis_reduction_constraint real, min_control_efficiency_constraint real,
	max_cost_per_ton_constraint real, max_ann_cost_constraint real) RETURNS integer AS $$
DECLARE
	dataset_month smallint := 0;
	no_days_in_month smallint := 31;
	has_constraints boolean := false;
BEGIN
	SET enable_seqscan TO 'off';
	SET work_mem TO '512MB';
--	SET enable_nestloop TO 'off';

	-- get month of the dataset, 0 (Zero) indicates an annual inventory
	select public.get_dataset_month(input_dataset_id)
	into dataset_month;

	IF dataset_month = 1 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 2 THEN
		no_days_in_month := 29;
	ELSIF dataset_month = 3 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 4 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 5 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 6 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 7 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 8 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 9 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 10 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 11 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 12 THEN
		no_days_in_month := 31;
	END IF;

	raise notice '%', 'start ' || strfipsst || ' ' || clock_timestamp();

	EXECUTE 'insert into emissions.' || detailed_result_table_name || ' 
		(
		dataset_id,
		cm_abbrev,
		poll,
		scc,
		fips,
		annual_cost,
		ann_cost_per_ton,
		control_eff,
		rule_pen,
		rule_eff,
		percent_reduction,
		final_emissions,
		emis_reduction,
		inv_emissions,
		fipsst,
		fipscty,
		source_id,
		input_ds_id,
		cs_id,
		cm_id
		)
	select 	' || detailed_result_dataset_id || '::integer,
		abbreviation,
		poll,
		scc,
		fips,
		ann_cost,
		ref_yr_cost_per_ton,
		efficiency,
		rule_pen,
		rule_eff,
		percent_reduction,
		final_emissions,
		emis_reduction,
		inv_emissions,
		fipsst,
		fipscty,
		source_id,
		' || input_dataset_id || '::integer,
		' || control_strategy_id || '::integer,
		cm_id
	from (
		select DISTINCT ON (inv.scc, inv.fips, er.pollutant_id, er.control_measures_id) 
			m.abbreviation,
			inv.poll,
			inv.scc,
			inv.fips,
			ref_yr_cost_per_ton * coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis) * efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100 / 100 as ann_cost,
			ref_yr_cost_per_ton,
			efficiency,
			' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' as rule_pen,
			' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' as rule_eff,
			efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100 as percent_reduction,
			' || case when dataset_month != 0 then 'coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis)' else 'inv.ann_emis' end || ' * (1 - efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100 / 100) as final_emissions,
			' || case when dataset_month != 0 then 'coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis)' else 'inv.ann_emis' end || ' * efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100 / 100 as emis_reduction,
			' || case when dataset_month != 0 then 'coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis)' else 'inv.ann_emis' end || ' as inv_emissions,
			substr(inv.fips, 1, 2) as fipsst,
			substr(inv.fips, 3, 3) as fipscty,
			inv.record_id::integer as source_id,
			er.control_measures_id as cm_id,
			' || case when measures_count > 0 then 'csm.apply_order ' else '1.0' end || ' as apply_order
		FROM emissions.' || inv_table_name || ' inv

			inner join emf.pollutants p
			on p.name = inv.poll

			inner join emf.control_measure_sccs scc
			on scc.name = inv.scc

			' || case when measures_count > 0 then '
			inner join emf.control_strategy_measures csm
			on csm.control_measure_id = scc.control_measures_id
			' else '' end || '

			' || case when measure_with_region_count > 0 and 1 = 0 then '
			left outer join measure_region mr
			on mr.control_measure_id = scc.control_measures_id
			and mr.fips = inv.fips
			' else '' end || '

			inner join emf.control_measures m
			on m.id = scc.control_measures_id

			inner join emf.control_measure_months ms
			on ms.control_measure_id = m.id
			and ms.month in (0' || case when dataset_month != 0 then ',' || dataset_month else '' end || ')

			inner join emf.control_measure_efficiencyrecords er
			on er.control_measures_id = scc.control_measures_id
			-- pollutant filter
			and er.pollutant_id = p.id
			-- min and max emission filter
			and ' || case when dataset_month != 0 then 'coalesce(inv.avd_emis * 365, inv.ann_emis)' else 'inv.ann_emis' end || ' between coalesce(er.min_emis, -1E+308) and coalesce(er.max_emis, 1E+308)
			-- locale filter
			and (er.locale = inv.fips or er.locale = substr(inv.fips, 1, 2) or er.locale = '''')
			-- effecive date filter
			and 2020::integer >= coalesce(date_part(''year'', er.effective_date), 2020::integer)

			' || case when measures_count = 0 and measure_classes_count > 0 then '
			inner join emf.control_strategy_classes csc
			on csc.control_measure_class_id = m.cm_class_id
			and csc.control_strategy_id = ' || control_strategy_id || '
			' else '' end || '

		where 	' || inv_filter || coalesce(county_dataset_filter_sql, '') || '
			and inv.fips like ' ||  quote_literal(strfipsst || '%') || '
			' || case when measures_count > 0 then '
			and csm.control_strategy_id = ' || control_strategy_id || '
			' else '' end || '
			' || case when measure_with_region_count > 0 and 1 = 0 then '
			and (
				(mr.control_measure_id is not null and mr.fips = inv.fips) 
				or (mr.control_measure_id is null)
			)' else '' end || '

		order by inv.scc, inv.fips, er.pollutant_id, er.control_measures_id, case when length(locale) = 5 then 0 when length(locale) = 2 then 1 else 2 end, ref_yr_cost_per_ton, efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' desc) as tbl
	order by scc, fips, poll, apply_order, coalesce(ref_yr_cost_per_ton, 0), percent_reduction desc';
	
	raise notice '%', 'end ' || strfipsst || ' ' || clock_timestamp();

	RETURN 1;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION public.run_apply_measures_in_series_strategy(control_strategy_id integer, input_dataset_id integer, 
	input_dataset_version integer, strategy_result_id int) RETURNS integer AS $$
DECLARE
--	control_strategy_id integer := null;
--	input_dataset_id integer := null;
--	input_dataset_version integer := null;
	inv_table_name varchar(63) := '';
	inv_filter varchar := '';
	inv_fips_filter text := '';
	detailed_result_dataset_id integer := null;
	detailed_result_table_name varchar(63) := '';
	county_dataset_id integer := null;
	county_dataset_version integer := null;
	region RECORD;
	target_pollutant_id integer := 0;
	target_pollutant varchar(255) := '';
	measure_with_region_count integer := 0;
	measures_count integer := 0;
	measure_classes_count integer := 0;
	min_emis_reduction_constraint real := null;
	min_control_efficiency_constraint real := null;
	max_cost_per_ton_constraint real := null;
	max_ann_cost_constraint real := null;
	has_constraints boolean := null;
	county_dataset_filter_sql text := '';
	cost_year integer := null;
	ref_cost_year integer := 2006;
	cost_year_chained_gdp double precision := null;
	ref_cost_year_chained_gdp double precision := null;
BEGIN
	SET work_mem TO '512MB';
	SET enable_seqscan TO 'off';

	-- get the input dataset info
	select i.table_name
	from emf.internal_sources i
	where i.dataset_id = input_dataset_id
	into inv_table_name;

	-- get the detailed result dataset info
	select sr.detailed_result_dataset_id,
		i.table_name
	from emf.strategy_results sr
		inner join emf.internal_sources i
		on i.dataset_id = sr.detailed_result_dataset_id
	where sr.id = strategy_result_id
	into detailed_result_dataset_id,
		detailed_result_table_name;

	-- see if control strategy has only certain measures specified
	SELECT count(id), 
		count(case when region_dataset_id is not null then 1 else null end)
	FROM emf.control_strategy_measures 
	where control_strategy_measures.control_strategy_id = control_strategy_id 
	INTO measures_count, 
		measure_with_region_count;

	-- see if measure classes were specified
	IF measures_count = 0 THEN
		SELECT count(1)
		FROM emf.control_strategy_classes 
		where control_strategy_classes.control_strategy_id = control_strategy_id
		INTO measure_classes_count;
	END IF;

	-- get target pollutant, inv filter, and county dataset info if specified
	SELECT cs.pollutant_id,
		case when length(trim(cs.filter)) > 0 then '(' || cs.filter || ')' else null end,
		cs.cost_year,
		cs.county_dataset_id,
		cs.county_dataset_version
	FROM emf.control_strategies cs
	where cs.id = control_strategy_id
	INTO target_pollutant_id,
		inv_filter,
		cost_year,
		county_dataset_id,
		county_dataset_version;
	
	select p.name
	FROM emf.pollutants p
	where p.id = target_pollutant_id
	INTO target_pollutant;

	-- get gdp chained values
	SELECT cast(chained_gdp as double precision)
	FROM reference.gdplev
	where annual = cost_year
	INTO cost_year_chained_gdp;
	SELECT cast(chained_gdp as double precision)
	FROM reference.gdplev
	where annual = ref_cost_year
	INTO ref_cost_year_chained_gdp;

	-- get strategy constraints
	SELECT max_emis_reduction,
		max_control_efficiency,
		min_cost_per_ton,
		min_ann_cost
	FROM emf.control_strategy_constraints csc
	where csc.control_strategy_id = control_strategy_id
	INTO min_emis_reduction_constraint,
		min_control_efficiency_constraint,
		max_cost_per_ton_constraint,
		max_ann_cost_constraint;

	select case when min_emis_reduction_constraint is not null 
		or min_control_efficiency_constraint is not null 
		or max_cost_per_ton_constraint is not null 
		or max_ann_cost_constraint is not null then true else false end
	into has_constraints;

	-- see if their was a county dataset specified for the strategy, is so then build a sql where clause filter for later use
	IF county_dataset_id is not null THEN
		county_dataset_filter_sql := ' and fips in (SELECT fips
			FROM emissions.' || (SELECT table_name FROM emf.internal_sources where dataset_id = county_dataset_id) || '
			where ' || public.build_version_where_filter(county_dataset_id, county_dataset_version) || ')';
/*
		FOR region IN EXECUTE 
			'SELECT fips
			FROM emissions.' || (SELECT table_name FROM emf.internal_sources where dataset_id = county_dataset_id) || '
			where ' || public.build_version_where_filter(county_dataset_id, county_dataset_version)
		LOOP
			IF length(inv_fips_filter) > 0 THEN
				inv_fips_filter := inv_fips_filter || ',' || quote_literal(region.fips);
			ELSE
				inv_fips_filter := inv_fips_filter || quote_literal(region.fips);
			END IF;
		END LOOP;
		IF length(inv_fips_filter) > 0 THEN 
			inv_filter := coalesce(inv_filter || ' and ', '') || 'fips in (' || inv_fips_filter || ')';
		END IF;
*/
	END IF;
	-- build version info into where clause filter
	inv_filter := '(' || public.build_version_where_filter(input_dataset_id, input_dataset_version) || ')' || coalesce(' and ' || inv_filter, '');

--	raise notice '%', 'inv_filter ' || inv_filter || clock_timestamp();

	-- if strategy have measures, then store these in a temp table for later use...
	IF measure_with_region_count > 0 THEN
		EXECUTE 'CREATE TEMP TABLE measure_region (control_measure_id integer NOT NULL, fips character varying(6) NOT NULL) ON COMMIT DROP;
--			CREATE INDEX measure_region_cl ON measure_region USING btree (control_measure_id, fips);
--			ALTER TABLE measure_region CLUSTER ON measure_region_cl;
			CREATE INDEX measure_region_measure_id ON measure_region USING btree (control_measure_id);
			CREATE INDEX measure_region_fips ON measure_region USING btree (fips);';

		FOR region IN EXECUTE 
			'SELECT m.control_measure_id, i.table_name, m.region_dataset_id, m.region_dataset_version
			FROM emf.control_strategy_measures m
				inner join emf.internal_sources i
				on m.region_dataset_id = i.dataset_id
			where m.control_strategy_id = ' || control_strategy_id || '
				and m.region_dataset_id is not null'
		LOOP
			EXECUTE 'insert into measure_region (control_measure_id, fips)
			SELECT ' || region.control_measure_id || ', fips
			FROM emissions.' || region.table_name || '
			where ' || public.build_version_where_filter(region.region_dataset_id, region.region_dataset_version);
		END LOOP;

	END IF;

	raise notice '%', 'start call_batch_state ' || clock_timestamp();

--	raise notice '%', 'inv_filter ' || inv_filter;
--	raise notice '%', 'county_dataset_filter_sql ' || county_dataset_filter_sql;

	execute 'select public.run_apply_measures_in_series_strategy_batch_by_state(' || control_strategy_id || ', ' || input_dataset_id  || ', 
		' || quote_literal(inv_table_name) || ', ' || quote_literal(inv_filter) || ', 
		' || detailed_result_dataset_id || ', ' || quote_literal(detailed_result_table_name) || ', 
		fipsst, ' || measures_count || ', 
		' || measure_classes_count || ', ' || target_pollutant_id || ', 
		' || measure_with_region_count || ', ' || quote_literal(coalesce(county_dataset_filter_sql, '')) || ',
		' || coalesce(min_emis_reduction_constraint || '', 'null') || ', ' || coalesce(min_control_efficiency_constraint || '', 'null') || ', 
		' || coalesce(max_cost_per_ton_constraint || '', 'null') || ', ' || coalesce(max_ann_cost_constraint || '', 'null') || ')
	from (
		SELECT DISTINCT ON (substring(fips, 1, 2)) substring(fips, 1, 2) as fipsst
		FROM emissions.' || inv_table_name || ' as inv
		where ' || inv_filter || county_dataset_filter_sql || '
		order by substring(fips, 1, 2) 
--		limit 1
	) fips';

	-- get rid of sources that use measures not in there county, this is post step becuase using a join during the measure selection process seem to be slower.
	IF measure_with_region_count > 0 THEN
--		execute 'raise notice ''%'', ''get rid of sources that use measures not in there county - before count '' || (select count(1) from emissions.' || detailed_result_table_name || ') || '' '' || clock_timestamp();';
--		raise notice '%', 'get rid of sources that use measures not in there county - before count ' || (select count(1) from emissions.csdr_test5) || ' ' || clock_timestamp();

/*		EXECUTE	'delete from only emissions.' || detailed_result_table_name || '
				where record_id in (
					select record_id
					from emissions.' || detailed_result_table_name || ' as inv
						inner join emf.control_strategy_measures csm
						on csm.control_measure_id = inv.cm_id
						and csm.region_dataset_id is not null
						left outer join measure_region mr
						on mr.control_measure_id = inv.cm_id
						and mr.fips = inv.fips
					where mr.fips is null
						and csm.control_strategy_id = ' || control_strategy_id || ')
		';
*/
		EXECUTE	'delete from only emissions.' || detailed_result_table_name || ' as inv2
			where	not exists (select 1
					from measure_region mr
					where mr.control_measure_id = inv2.cm_id
						and mr.fips = inv2.fips
					)

				and exists (select 1 
					from emf.control_strategy_measures csm
					where csm.control_strategy_id = ' || control_strategy_id || '
						and csm.control_measure_id = inv2.cm_id
						and csm.region_dataset_id is not null
					)

		';
--		raise notice '%', 'after count ' || (select count(1) from emissions.csdr_test5) || ' ' || clock_timestamp();
	END IF;

--	SET enable_seqscan TO 'on';
--	execute 'raise notice ''%'', ''readjust detailed result - count '' || (select count(1) from emissions.' || detailed_result_table_name || ') || '' '' || clock_timestamp();';

	-- update the detailed result
/*raise notice '%', 
	'update emissions.' || detailed_result_table_name || ' as inv
	set 	inv_emissions = case when (select min(inv2.record_id) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) = inv.record_id then inv.inv_emissions else null end,
		final_emissions = case when (select max(inv2.record_id) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) = inv.record_id then inv.inv_emissions * (select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) else null end,
		emis_reduction = inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		annual_cost = inv.ann_cost_per_ton * inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		apply_order = (select count(1) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id <= inv.record_id)';
*/
	EXECUTE	'update emissions.' || detailed_result_table_name || ' as inv
	set 	emis_reduction = inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		annual_cost = ' || cost_year_chained_gdp || ' / ' || ref_cost_year_chained_gdp || ' * inv.ann_cost_per_ton * inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		apply_order = (select count(1) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id <= inv.record_id),
		input_emis = inv.inv_emissions * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		output_emis = inv.inv_emissions * (1 - inv.percent_reduction / 100) * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		final_emissions = null,
		ann_cost_per_ton = ' || cost_year_chained_gdp || ' / ' || ref_cost_year_chained_gdp || ' * ann_cost_per_ton';

	-- make sure we meet the constraints, if not get rid of the applicable measures...
	IF has_constraints THEN
--		raise notice '%', 'get rid of sources that use measures not in there county - before count ' || (select count(1) from emissions.csdr_test5) || ' ' || clock_timestamp();
/*		execute 'create table emissions.noconstraints as 
			select scc, fips, cm_id, inv2.percent_reduction, inv2.poll, inv2.emis_reduction, inv2.ann_cost_per_ton, inv2.annual_cost
			from emissions.' || detailed_result_table_name || ' as inv2
			where inv2.poll = ' || quote_literal(target_pollutant) || '';
		execute 'create table emissions.constraints as 
			select scc, fips, cm_id, inv2.percent_reduction, inv2.poll, inv2.emis_reduction, inv2.ann_cost_per_ton, inv2.annual_cost
			from emissions.' || detailed_result_table_name || ' as inv2
			where inv2.poll = ' || quote_literal(target_pollutant) || '
				and (
					inv2.percent_reduction < ' || coalesce(min_control_efficiency_constraint, -100.0) || '
					' || coalesce(' or inv2.emis_reduction < ' || min_emis_reduction_constraint, '')  || '
					' || coalesce(' or inv2.ann_cost_per_ton > ' || max_cost_per_ton_constraint, '')  || '
					' || coalesce(' or inv2.annual_cost > ' || max_ann_cost_constraint, '')  || '
				)';
*/
		execute 'delete from emissions.' || detailed_result_table_name || ' as inv
			using emissions.' || detailed_result_table_name || ' as inv2
			where not exists (select 1 
				from emissions.' || detailed_result_table_name || ' as inv2
				where inv2.scc = inv.scc
				and inv2.fips = inv.fips
				and inv2.cm_id = inv.cm_id
				and inv2.poll = ' || quote_literal(target_pollutant) || '
				and (
					inv2.percent_reduction > ' || coalesce(min_control_efficiency_constraint, -100.0) || '
					' || coalesce(' and inv2.emis_reduction > ' || min_emis_reduction_constraint, '')  || '
					' || coalesce(' and coalesce(inv2.ann_cost_per_ton, -1E+308) < ' || max_cost_per_ton_constraint, '')  || '
					' || coalesce(' and coalesce(inv2.annual_cost, -1E+308) < ' || max_ann_cost_constraint, '')  || '
				))
				and exists (select 1 
					from emissions.' || detailed_result_table_name || ' as inv3
					where inv3.fips = inv.fips
						and inv3.scc = inv.scc
						and inv3.poll = ' || quote_literal(target_pollutant) || '
					)
				';
		-- update the apply order again, there are bound to be gaps...
		EXECUTE	'update emissions.' || detailed_result_table_name || ' as inv
		set 	apply_order = (select count(1) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id <= inv.record_id)';

	END IF;

/*	'inv_emissions = case when (select min(inv2.record_id) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) = inv.record_id then inv.inv_emissions else null end,
		final_emissions = case when (select max(inv2.record_id) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) = inv.record_id then inv.inv_emissions * (select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) else null end,
		emis_reduction = inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		annual_cost = inv.ann_cost_per_ton * inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		apply_order = (select count(1) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id <= inv.record_id)';
*/
	EXECUTE	'update emissions.' || detailed_result_table_name || ' as inv
	set 	inv_emissions = null 
	where apply_order > 1';

	EXECUTE	'update emissions.' || detailed_result_table_name || ' as inv
	set 	final_emissions = (select min(output_emis) from emissions.' || detailed_result_table_name || ' where source_id = inv.source_id)
	where apply_order = 1 ';

	raise notice '%', 'end call_batch_state ' || clock_timestamp();

	RETURN 1;
END;
$$ LANGUAGE plpgsql;

-- COST EQUATIONS

CREATE OR REPLACE FUNCTION public.get_strategy_costs(use_cost_equations boolean, control_measure_id integer, 
	measure_abbreviation character varying(10), discount_rate double precision, 
	equipment_life double precision, capital_annualized_ratio double precision, 
	capital_recovery_factor double precision, ref_yr_cost_per_ton double precision,  
	emis_reduction double precision, ref_yr_chained_gdp_adjustment_factor double precision,
	equation_type character varying(255), 
	variable_coefficient1 double precision, variable_coefficient2 double precision, 
	variable_coefficient3 double precision, variable_coefficient4 double precision, 
	variable_coefficient5 double precision, variable_coefficient6 double precision, 
	variable_coefficient7 double precision, variable_coefficient8 double precision, 
	variable_coefficient9 double precision, variable_coefficient10 double precision, 
	stack_flow_rate double precision, design_capacity double precision, 
	design_capacity_unit_numerator character varying, design_capacity_unit_denominator character varying, 
	OUT annual_cost double precision, OUT capital_cost double precision, 
	OUT operation_maintenance_cost double precision, OUT annualized_capital_cost double precision, 
	OUT computed_cost_per_ton double precision)  AS $$
DECLARE
	converted_design_capacity double precision;
BEGIN
	-- try cost equations first, then maybe use default approach, if needed
	IF use_cost_equations THEN
		IF equation_type is not null THEN
			-- Type 1
			IF equation_type = 'Type 1' THEN

				converted_design_capacity := public.convert_design_capacity_to_mw(design_capacity, design_capacity_unit_numerator, design_capacity_unit_denominator);

				IF coalesce(design_capacity, 0) <> 0 THEN
					select costs.annual_cost,
						costs.capital_cost,
						costs.operation_maintenance_cost,
						costs.annualized_capital_cost,
						costs.computed_cost_per_ton
					from public.get_type1_equation_costs(control_measure_id, measure_abbreviation,
						discount_rate, equipment_life,
						capital_recovery_factor, emis_reduction, 
						ref_yr_chained_gdp_adjustment_factor, converted_design_capacity,
						variable_coefficient1, variable_coefficient2, 
						variable_coefficient3, variable_coefficient4, 
						variable_coefficient5, variable_coefficient6) as costs
					into annual_cost,
						capital_cost,
						operation_maintenance_cost,
						annualized_capital_cost,
						computed_cost_per_ton;
					return;
				END IF;
			END IF;

			-- Type 2
			IF equation_type = 'Type 2' THEN

				converted_design_capacity := public.convert_design_capacity_to_mw(design_capacity, design_capacity_unit_numerator, design_capacity_unit_denominator);

-- validate the inputs...
-- if they missing, use the default
				IF coalesce(converted_design_capacity, 0) <> 0 THEN
-- design capacity must be less than or equal to 2000 MMBTU/hr (or 586.1665 MW))
					IF (converted_design_capacity <= 586.1665) THEN
						select costs.annual_cost,
							costs.capital_cost,
							costs.operation_maintenance_cost,
							costs.annualized_capital_cost,
							costs.computed_cost_per_ton
						from public.get_type2_equation_costs(control_measure_id, discount_rate, 
							equipment_life, capital_recovery_factor, 
							emis_reduction, ref_yr_chained_gdp_adjustment_factor, 
							converted_design_capacity, variable_coefficient1, 
							variable_coefficient2, variable_coefficient3, 
							variable_coefficient4) as costs
						into annual_cost,
							capital_cost,
							operation_maintenance_cost,
							annualized_capital_cost,
							computed_cost_per_ton;
						return;
					END IF;
				END IF;
			END IF;

			-- Type 8
			IF equation_type = 'Type 8' THEN
				IF coalesce(stack_flow_rate, 0) <> 0 THEN
					select costs.annual_cost,
						costs.capital_cost,
						costs.operation_maintenance_cost,
						costs.annualized_capital_cost,
						costs.computed_cost_per_ton
					from public.get_type8_equation_costs(control_measure_id, discount_rate, 
						equipment_life, capital_recovery_factor, 
						emis_reduction, ref_yr_chained_gdp_adjustment_factor, 
						stack_flow_rate,
						variable_coefficient1, variable_coefficient2, 
						variable_coefficient3, variable_coefficient4, 
						variable_coefficient5) as costs
					into annual_cost,
						capital_cost,
						operation_maintenance_cost,
						annualized_capital_cost,
						computed_cost_per_ton;
					return;
				END IF;
			END IF;
		END IF;
	END IF;

	select costs.annual_cost,
		costs.capital_cost,
		costs.operation_maintenance_cost,
		costs.annualized_capital_cost,
		costs.computed_cost_per_ton
	from public.get_default_costs(discount_rate, equipment_life, 
		capital_annualized_ratio, capital_recovery_factor, 
		ref_yr_cost_per_ton, emis_reduction) as costs
	into annual_cost,
		capital_cost,
		operation_maintenance_cost,
		annualized_capital_cost,
		computed_cost_per_ton;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.get_default_costs(discount_rate double precision, equipment_life double precision,
	capital_annualized_ratio double precision, capital_recovery_factor double precision, 
	ref_yr_cost_per_ton double precision, emis_reduction double precision, 
	OUT annual_cost double precision, OUT capital_cost double precision,
	OUT operation_maintenance_cost double precision, OUT annualized_capital_cost double precision,
	OUT computed_cost_per_ton double precision)  AS $$
DECLARE
	cap_recovery_factor double precision := capital_recovery_factor;
BEGIN
	-- get capital recovery factor, caculate if it wasn't passed in...
        IF coalesce(cap_recovery_factor, 0) = 0 and coalesce(discount_rate, 0) != 0 and coalesce(equipment_life, 0) != 0 THEN 
             cap_recovery_factor := public.calculate_capital_recovery_factor(discount_rate, equipment_life);
        END IF;

	-- calculate annual cost
	annual_cost := emis_reduction * ref_yr_cost_per_ton;
	-- calculate capital cost
	capital_cost := annual_cost  * capital_annualized_ratio;
	-- calculate annualized capital cost
	annualized_capital_cost := capital_cost * cap_recovery_factor;
	-- calculate operation maintenance cost
	operation_maintenance_cost := annual_cost - coalesce(annualized_capital_cost, 0);
	-- calculate computed cost per ton
	computed_cost_per_ton := 
		case 
			when coalesce(emis_reduction, 0) <> 0 then annual_cost / emis_reduction
			else null
		end;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.calculate_capital_recovery_factor(discount_rate double precision, equipment_life double precision) returns double precision AS $$
DECLARE
BEGIN
	IF coalesce(discount_rate, 0) = 0 or coalesce(equipment_life, 0) = 0 THEN
		return null;
	END IF;

	return (discount_rate * (1 + discount_rate) ^ equipment_life) / ((discount_rate + 1) ^ equipment_life - 1);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.get_type1_equation_costs(control_measure_id integer, measure_abbreviation character varying(10),
	discount_rate double precision, equipment_life double precision,
	capital_recovery_factor double precision, emis_reduction double precision, 
	ref_yr_chained_gdp_adjustment_factor double precision, design_capacity double precision,

 	capital_cost_multiplier double precision,
	fixed_om_cost_multiplier double precision,
	variable_om_cost_multiplier double precision,
	scaling_factor_model_size double precision,
	scaling_factor_exponent double precision,
	capacity_factor double precision,

	OUT annual_cost double precision, OUT capital_cost double precision,
	OUT operation_maintenance_cost double precision, OUT annualized_capital_cost double precision,
	OUT computed_cost_per_ton double precision)  AS $$
DECLARE
	cap_recovery_factor double precision := capital_recovery_factor;
	scaling_factor double precision;
	fixed_operation_maintenance_cost double precision;
	variable_operation_maintenance_cost double precision;
BEGIN
	-- get capital recovery factor, caculate if it wasn't passed in...
        IF coalesce(cap_recovery_factor, 0) = 0 and coalesce(discount_rate, 0) != 0 and coalesce(equipment_life, 0) != 0 THEN 
             cap_recovery_factor := public.calculate_capital_recovery_factor(discount_rate, equipment_life);
        END IF;

	-- calculate scaling factor
	scaling_factor := 
		case 
			when (measure_abbreviation = 'NSCR_UBCW' or measure_abbreviation = 'NSCR_UBCT') and design_capacity >= 600.0 then 1.0
			when design_capacity >= 500.0 then 1.0
			else scaling_factor_model_size ^ scaling_factor_exponent
		end;

	-- calculate capital cost
	capital_cost := ref_yr_chained_gdp_adjustment_factor * capital_cost_multiplier * design_capacity * scaling_factor * 1000;

	-- calculate operation maintenance cost
	-- calculate fixed operation maintenance cost
	fixed_operation_maintenance_cost := ref_yr_chained_gdp_adjustment_factor * fixed_om_cost_multiplier * design_capacity * 1000;
	-- calculate variable operation maintenance cost
	variable_operation_maintenance_cost := ref_yr_chained_gdp_adjustment_factor * variable_om_cost_multiplier * design_capacity * capacity_factor * 8760;
	-- calculate total operation maintenance cost
	operation_maintenance_cost := coalesce(fixed_operation_maintenance_cost, 0) + coalesce(variable_operation_maintenance_cost, 0);

	-- calculate annualized capital cost
	annualized_capital_cost := capital_cost * cap_recovery_factor;

	-- calculate annual cost
	annual_cost := annualized_capital_cost + operation_maintenance_cost;

	-- calculate computed cost per ton
	computed_cost_per_ton := 
		case 
			when coalesce(emis_reduction, 0) <> 0 then annual_cost / emis_reduction
			else null
		end;
END;
$$ LANGUAGE plpgsql IMMUTABLE;


CREATE OR REPLACE FUNCTION public.get_type8_equation_costs(control_measure_id integer, discount_rate double precision, 
	equipment_life double precision, capital_recovery_factor double precision, 
	emis_reduction double precision, ref_yr_chained_gdp_adjustment_factor double precision, 
	stack_flow_rate double precision, 

	capital_control_cost_factor double precision,
	om_control_cost_factor double precision,
	default_capital_cpt_factor double precision,
	default_om_cpt_factor double precision,
	default_annualized_cpt_factor double precision,

	OUT annual_cost double precision, OUT capital_cost double precision,
	OUT operation_maintenance_cost double precision, OUT annualized_capital_cost double precision,
	OUT computed_cost_per_ton double precision)  AS $$
DECLARE
	cap_recovery_factor double precision := capital_recovery_factor;
BEGIN
	-- * Comments *




	-- * Comments *

	-- get capital recovery factor, caculate if it wasn't passed in...
        IF coalesce(cap_recovery_factor, 0) = 0 and coalesce(discount_rate, 0) != 0 and coalesce(equipment_life, 0) != 0 THEN 
             cap_recovery_factor := public.calculate_capital_recovery_factor(discount_rate, equipment_life);
        END IF;

	-- calculate capital cost
	capital_cost := 
		case 
			when coalesce(stack_flow_rate, 0) = 0 then null
			when stack_flow_rate >= 5.0 then ref_yr_chained_gdp_adjustment_factor * capital_control_cost_factor * stack_flow_rate
			else ref_yr_chained_gdp_adjustment_factor * default_capital_cpt_factor * emis_reduction
		end;

	-- calculate operation maintenance cost
	operation_maintenance_cost := 
		case 
			when coalesce(stack_flow_rate, 0) = 0 then null
			when stack_flow_rate >= 5.0 then ref_yr_chained_gdp_adjustment_factor * om_control_cost_factor * stack_flow_rate
			else ref_yr_chained_gdp_adjustment_factor * default_om_cpt_factor * emis_reduction
		end;

	-- calculate annualized capital cost
	annualized_capital_cost := capital_cost * cap_recovery_factor;

	-- calculate annual cost
	annual_cost :=  
		case 
			when coalesce(stack_flow_rate, 0) = 0 then null
			when stack_flow_rate >= 5.0 then annualized_capital_cost + 0.04 * capital_cost + operation_maintenance_cost
			else ref_yr_chained_gdp_adjustment_factor * default_annualized_cpt_factor * emis_reduction
		end;

	-- calculate computed cost per ton
	computed_cost_per_ton := 
		case 
			when coalesce(emis_reduction, 0) <> 0 then annual_cost / emis_reduction
			else null
		end;
END;
$$ LANGUAGE plpgsql IMMUTABLE;


CREATE OR REPLACE FUNCTION public.get_type2_equation_costs(control_measure_id integer, discount_rate double precision, 
	equipment_life double precision, capital_recovery_factor double precision, 
	emis_reduction double precision, ref_yr_chained_gdp_adjustment_factor double precision, 
	design_capacity double precision, capital_cost_multiplier double precision,
	capital_cost_exponent double precision, annual_cost_multiplier double precision,
	annual_cost_exponent double precision, OUT annual_cost double precision, 
	OUT capital_cost double precision, OUT operation_maintenance_cost double precision, 
	OUT annualized_capital_cost double precision, OUT computed_cost_per_ton double precision)  AS $$
DECLARE
	cap_recovery_factor double precision := capital_recovery_factor;
BEGIN
	-- get capital recovery factor, caculate if it wasn't passed in...
        IF coalesce(cap_recovery_factor, 0) = 0 and coalesce(discount_rate, 0) != 0 and coalesce(equipment_life, 0) != 0 THEN 
             cap_recovery_factor := public.calculate_capital_recovery_factor(discount_rate, equipment_life);
        END IF;

	-- calculate capital cost
	capital_cost := ref_yr_chained_gdp_adjustment_factor * capital_cost_multiplier * design_capacity ^ capital_cost_exponent;

	-- calculate annualized capital cost
	annualized_capital_cost := capital_cost * cap_recovery_factor;

	-- calculate annual cost
	annual_cost := ref_yr_chained_gdp_adjustment_factor * annual_cost_multiplier * design_capacity ^ annual_cost_exponent;

	-- calculate operation maintenance cost
	operation_maintenance_cost := annual_cost - annualized_capital_cost;

	-- calculate computed cost per ton
	computed_cost_per_ton := 
		case 
			when coalesce(emis_reduction, 0) <> 0 then annual_cost / emis_reduction
			else null
		end;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.convert_design_capacity_to_mw(design_capacity double precision, design_capacity_unit_numerator character varying, 
	design_capacity_unit_denominator character varying) returns double precision AS $$
DECLARE
	converted_design_capacity double precision;
	unit_numerator character varying;
	unit_denominator character varying;
BEGIN

        --default if not known
        unit_numerator := coalesce(trim(upper(design_capacity_unit_numerator)), '');
        unit_denominator := coalesce(trim(upper(design_capacity_unit_denominator)), '');

        --if you don't know the units then you can't convert the design capacity
        IF length(unit_numerator) = 0 THEN
            return converted_design_capacity;
	END IF;


/* FROM Larry Sorrels at the EPA
        1) E6BTU does mean mmBTU.

        2)  1 MW = 3.412 million BTU/hr (or mmBTU/hr).   And conversely, 1
        mmBTU/hr = 1/3.412 (or 0.2931) MW.

        3)  All of the units listed below are convertible, but some of the
        conversions will be more difficult than others.  The ft3, lb, and ton
        will require some additional conversions to translate mass or volume
        into an energy term such as MW or mmBTU/hr.  Applying some density
        measure (which is mass/volume) will likely be necessary.   Let me know
        if you need help with the conversions. 
*/

        --capacity is already in the right units...
        --no conversion is necessary, these are the expected units.
        IF (unit_numerator = 'MW' and unit_denominator = '') THEN
            return design_capacity;
	END IF;

        IF (unit_numerator = 'MMBTU'
                or unit_numerator = 'E6BTU'
                or unit_numerator = 'BTU'
                or unit_numerator = 'HP'
                or unit_numerator = 'BLRHP') THEN

           --convert numerator unit
		IF (unit_numerator = 'MMBTU'
		    or unit_numerator = 'E6BTU') THEN
			converted_design_capacity := design_capacity / 3.412;
		END IF;
		IF (unit_numerator = 'BTU') THEN
			converted_design_capacity := design_capacity / 3.412 / 1000000.0;
		END IF;
		IF (unit_numerator = 'HP') THEN
                converted_design_capacity := design_capacity * 0.000746;
		END IF;
		IF (unit_numerator = 'BLRHP') THEN
			converted_design_capacity := design_capacity * 0.000981;
		END IF;
--            IF (unit_numerator = 'FT3') THEN
--                converted_design_capacity := design_capacity * 0.000981;

            --convert denominator unit, if missing ASSUME per hr
            IF (unit_denominator = '' or unit_denominator = 'HR'
                    or unit_denominator = 'H') THEN
                return converted_design_capacity;
 		END IF;
           IF (unit_denominator = 'D' or unit_denominator = 'DAY') THEN
                return converted_design_capacity * 24.0;
		END IF;
            IF (unit_denominator = 'M' or unit_denominator = 'MIN') THEN
                return converted_design_capacity / 60.0;
		END IF;
            IF (unit_denominator = 'S' or unit_denominator = 'SEC') THEN
                return converted_design_capacity / 3600.0;
		END IF;
        END IF;
        return null;
END;
$$ LANGUAGE plpgsql IMMUTABLE;



CREATE OR REPLACE FUNCTION public.run_max_emis_red_strategy_by_state(control_strategy_id integer, input_dataset_id integer, 
	inv_table_name varchar(63), inv_filter varchar, 
	detailed_result_dataset_id integer, detailed_result_table_name varchar(63), 
	strfipsst varchar(2), measures_count integer, 
	measure_with_region_count integer, measure_classes_count integer, 
	target_pollutant_id integer, inventory_year integer, 
	county_dataset_filter_sql text, is_point_table boolean, 
	dataset_month smallint, no_days_in_month smallint, 
	min_emis_reduction_constraint real, min_control_efficiency_constraint real, 
	max_cost_per_ton_constraint real, max_ann_cost_constraint real, 
	has_constraints boolean, chained_gdp_adjustment_factor double precision, 
	use_cost_equations boolean, discount_rate double precision, 
	ref_cost_year_chained_gdp double precision) RETURNS void AS $$
DECLARE
	get_strategt_cost_sql character varying;
	get_strategt_cost_inner_sql character varying;
	annualized_emis_sql character varying;
	annual_emis_sql character varying;
	percent_reduction_sql character varying;
BEGIN
	SET enable_seqscan TO 'off';
	SET work_mem TO '512MB';
--	SET enable_nestloop TO 'off';

	annual_emis_sql := case when dataset_month != 0 then 'coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis)' else 'inv.ann_emis' end;
	annualized_emis_sql := case when dataset_month != 0 then 'coalesce(inv.avd_emis * 365, inv.ann_emis)' else 'inv.ann_emis' end;
	percent_reduction_sql := 'er.efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100';
	get_strategt_cost_sql := '(public.get_strategy_costs(' || case when use_cost_equations then 'true' else 'false' end || '::boolean, m.control_measures_id, 
			abbreviation, ' || discount_rate|| ', 
			m.equipment_life, er.cap_ann_ratio, 
			er.cap_rec_factor, er.ref_yr_cost_per_ton, 
			' || annual_emis_sql || ' * ' || percent_reduction_sql || ' / 100, ' || ref_cost_year_chained_gdp || ' / cast(chained_gdp as double precision), 
			' || case when use_cost_equations then 
			'et.name, 
			eq.value1, eq.value2, 
			eq.value3, eq.value4, 
			eq.value5, eq.value6, 
			eq.value7, eq.value8, 
			eq.value9, eq.value10, 
			' || case when not is_point_table then 'null' else 'inv.stkflow' end || ', ' || case when not is_point_table then 'null' else 'inv.design_capacity' end || ', 
			' || case when not is_point_table then 'null' else 'inv.design_capacity_unit_numerator' end || ', ' || case when not is_point_table then 'null' else 'inv.design_capacity_unit_denominator' end 
			else
			'null, 
			null, null, 
			null, null, 
			null, null, 
			null, null, 
			null, null, 
			null, null, 
			null, null'
			end
			|| '))';
	get_strategt_cost_inner_sql := replace(get_strategt_cost_sql,'m.control_measures_id','m.id');

	raise notice '%', 'start ' || strfipsst || ' ' || clock_timestamp();

	execute 'insert into emissions.' || detailed_result_table_name || ' 
		(
		dataset_id,
		cm_abbrev,
		poll,
		scc,
		fips,
		' || case when is_point_table = false then '' else 'plantid, pointid, stackid, segment, ' end || '
		annual_oper_maint_cost,
		annualized_capital_cost,
		total_capital_cost,
		annual_cost,
		ann_cost_per_ton,
		control_eff,
		rule_pen,
		rule_eff,
		percent_reduction,
		final_emissions,
		emis_reduction,
		inv_emissions,
		input_emis,
		output_emis,
		apply_order,
		fipsst,
		fipscty,
		source_id,
		input_ds_id,
		cs_id,
		cm_id,
		equation_type,
		"comment"
		)
	select DISTINCT ON (inv.fips, inv.scc, ' || case when is_point_table = false then '' else 'inv.plantid, inv.pointid, inv.stackid, inv.segment, ' end || 'er.pollutant_id) 
		' || detailed_result_dataset_id || '::integer,
		abbreviation,
		inv.poll,
		inv.scc,
		inv.fips,
		' || case when is_point_table = false then '' else 'inv.plantid, inv.pointid, inv.stackid, inv.segment, ' end || '
		TO_CHAR(' || chained_gdp_adjustment_factor || ' * ' || get_strategt_cost_sql || '.operation_maintenance_cost, ''FM999999999999999990.99'')::double precision as operation_maintenance_cost,
		TO_CHAR(' || chained_gdp_adjustment_factor || ' * ' || get_strategt_cost_sql || '.annualized_capital_cost, ''FM999999999999999990.99'')::double precision as annualized_capital_cost,
		TO_CHAR(' || chained_gdp_adjustment_factor || ' * ' || get_strategt_cost_sql || '.capital_cost, ''FM999999999999999990.99'')::double precision as capital_cost,
		TO_CHAR(' || chained_gdp_adjustment_factor || ' * ' || get_strategt_cost_sql || '.annual_cost, ''FM999999999999999990.99'')::double precision as ann_cost,
		TO_CHAR(' || chained_gdp_adjustment_factor || ' * ' || get_strategt_cost_sql || '.computed_cost_per_ton, ''FM999999999999999990.99'')::double precision as computed_cost_per_ton,
		TO_CHAR(er.efficiency, ''FM990.999'')::double precision as efficiency,
		TO_CHAR(' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ', ''FM990.999'')::double precision as rule_pen,
		TO_CHAR(' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ', ''FM990.999'')::double precision as rule_eff,
		TO_CHAR(' || percent_reduction_sql || ', ''FM990.999'')::double precision as percent_reduction,
		' || annual_emis_sql || ' * (1 - ' || percent_reduction_sql || ' / 100) as final_emissions,
		' || annual_emis_sql || ' * ' || percent_reduction_sql || ' / 100 as emis_reduction,
		' || annual_emis_sql || ' as inv_emissions,
		' || annual_emis_sql || ' as input_emis,
		' || annual_emis_sql || ' * (1 - ' || percent_reduction_sql || ' / 100) as output_emis,
		1,
		substr(inv.fips, 1, 2),
		substr(inv.fips, 3, 3),
		inv.record_id::integer as source_id,
		' || input_dataset_id || '::integer,
		' || control_strategy_id || '::integer,
		er.control_measures_id,
		et.name as equation_type,
		''''
	FROM emissions.' || inv_table_name || ' inv

		inner join emf.pollutants p
		on p.name = inv.poll

		inner join (
			-- second pass, gets rid of ties for a paticular source
			select DISTINCT ON (fips, scc' || case when is_point_table = false then '' else ', plantid, pointid, stackid, segment' end || ') 
				abbreviation,
				scc,
				fips,
				' || case when is_point_table = false then '' else 'plantid, pointid, stackid, segment, ' end || '
				control_measures_id,
				equipment_life
			from (
				-- get best measures for sources target pollutants, there could be a tie for a paticular source.
				select DISTINCT ON (inv.fips, inv.scc' || case when is_point_table = false then '' else ', inv.plantid, inv.pointid, inv.stackid, inv.segment' end || ', er.control_measures_id) 
					m.abbreviation,
					inv.scc,
					inv.fips,
					' || case when is_point_table = false then '' else 'inv.plantid, inv.pointid, inv.stackid, inv.segment,' end || '
					er.control_measures_id,
					' || percent_reduction_sql || ' as percent_reduction,
					' || get_strategt_cost_inner_sql || '.computed_cost_per_ton as computed_cost_per_ton,
					m.equipment_life
--,cstp.precedence

				FROM emissions.' || inv_table_name || ' inv

					inner join emf.pollutants p
					on p.name = inv.poll

--					inner join (
--						select fips, scc, plantid, poll, sum(' || annual_emis_sql || ') as total_ann_emis
--						from emissions.' || inv_table_name || ' as inv
--						group by fips, scc, plantid, poll) source_total
--					on source_total.fips = inv.fips
--					and source_total.scc = inv.scc
--					and source_total.plantid = inv.plantid
--					and source_total.poll = inv.poll
					
					inner join emf.control_measure_sccs scc
					on scc.name = inv.scc
					
					' || case when measures_count > 0 then '
					inner join emf.control_strategy_measures csm
					on csm.control_measure_id = scc.control_measures_id
					and csm.control_strategy_id = ' || control_strategy_id || '
					' else '' end || '

			--this part will get applicable measure based on the target pollutant, use this measure for target and cobenefit pollutants...
					inner join emf.control_measures m
					on m.id = scc.control_measures_id

					inner join emf.control_measure_months ms
					on ms.control_measure_id = m.id
					and ms.month in (0' || case when dataset_month != 0 then ',' || dataset_month else '' end || ')

					left outer join emf.control_measure_equations eq
					on eq.control_measure_id = m.id
					and eq.pollutant_id = p.id

					left outer join emf.equation_types et
					on et.id = eq.equation_type_id

					left outer join reference.gdplev
					on gdplev.annual = eq.cost_year

					inner join emf.control_measure_efficiencyrecords er
					on er.control_measures_id = scc.control_measures_id
					-- pollutant filter
					and er.pollutant_id = p.id
					-- min and max emission filter
					and ' || annualized_emis_sql || ' between coalesce(er.min_emis, -1E+308) and coalesce(er.max_emis, 1E+308)
--					and source_total.total_ann_emis between coalesce(er.min_emis, -1E+308) and coalesce(er.max_emis, 1E+308)
					-- locale filter
					and (er.locale = inv.fips or er.locale = substr(inv.fips, 1, 2) or er.locale = '''')
					-- effecive date filter
					and ' || inventory_year || '::integer >= coalesce(date_part(''year'', er.effective_date), ' || inventory_year || '::integer)		

					' || case when measures_count = 0 and measure_classes_count > 0 then '
					inner join emf.control_strategy_classes csc
					on csc.control_measure_class_id = m.cm_class_id
					and csc.control_strategy_id = ' || control_strategy_id || '
					' else '' end || '

					-- target pollutant filter
--					inner join emf.control_strategy_target_pollutants cstp
--					on cstp.pollutant_id = p.id
--					and cstp.control_strategy_id = ' || control_strategy_id || '

				where 	' || inv_filter || coalesce(county_dataset_filter_sql, '') || '
					and inv.fips like ' ||  quote_literal(strfipsst || '%') || '
					and p.id = ' ||  target_pollutant_id || '
					-- measure region filter
					' || case when measure_with_region_count > 0 then '
					and 
					(
						csm.region_dataset_id is null 
						or
						(
							csm.region_dataset_id is not null 
							and exists (
								select 1
								from measures mr
									inner join measure_regions r
									on r.region_id = mr.region_id
									and r.region_version = mr.region_version
								where mr.control_measure_id = m.id
									and r.fips = inv.fips
							)
							and exists (
								select 1 
								from measures mr
								where mr.control_measure_id = m.id
							)
						)
					)					
					' else '' end || '
					-- constraints filter
					' || case when has_constraints then '
					and (
							' || percent_reduction_sql || ' >= ' || coalesce(min_control_efficiency_constraint, -100.0) || '
							' || coalesce(' and ' || percent_reduction_sql || ' / 100 * ' || annualized_emis_sql || ' >= ' || min_emis_reduction_constraint, '')  || '
							' || coalesce(' and coalesce(' || chained_gdp_adjustment_factor || '
								* ' || get_strategt_cost_inner_sql || '.computed_cost_per_ton, -1E+308) <= ' || max_cost_per_ton_constraint, '')  || '
							' || coalesce(' and coalesce(' || percent_reduction_sql || ' / 100 * ' || annualized_emis_sql || ' * ' || chained_gdp_adjustment_factor || '
								* ' || get_strategt_cost_inner_sql || '.computed_cost_per_ton, -1E+308) <= ' || max_ann_cost_constraint, '')  || '
					)' else '' end || '

				order by inv.fips, 
					inv.scc, ' || case when is_point_table = false then '' else 'inv.plantid, inv.pointid, inv.stackid, inv.segment, ' end || '
					er.control_measures_id, 
					case when length(er.locale) = 5 then 0 when length(er.locale) = 2 then 1 else 2 end, 
					' || percent_reduction_sql || ' desc, 
					' || get_strategt_cost_inner_sql || '.computed_cost_per_ton
			) sm
			order by fips, 
				scc,' || case when is_point_table = false then '' else 'plantid, pointid, stackid, segment, ' end || '
--				precedence,
				percent_reduction desc, 
				computed_cost_per_ton
		) m
		on m.scc = inv.scc
		and m.fips = inv.fips
		' || case when is_point_table = false then '' else '
		and m.plantid = inv.plantid
		and m.pointid = inv.pointid
		and m.stackid = inv.stackid
		and m.segment = inv.segment' end || '

		' || case when measures_count > 0 then '
		inner join emf.control_strategy_measures csm
		on csm.control_measure_id = m.control_measures_id
		and csm.control_strategy_id = ' || control_strategy_id || '
		' else '' end || '

		left outer join emf.control_measure_equations eq
		on eq.control_measure_id = m.control_measures_id
		and eq.pollutant_id = p.id

		left outer join emf.equation_types et
		on et.id = eq.equation_type_id

		left outer join reference.gdplev
		on gdplev.annual = eq.cost_year

--					inner join (
--						select fips, scc, plantid, poll, sum(' || annual_emis_sql || ') as total_ann_emis
--						from emissions.' || inv_table_name || ' as inv
--						group by fips, scc, plantid, poll) source_total
--					on source_total.fips = inv.fips
--					and source_total.scc = inv.scc
--					and source_total.plantid = inv.plantid
--					and source_total.poll = inv.poll
					
--this part will get best eff rec...
		inner join emf.control_measure_efficiencyrecords er
		on er.control_measures_id = m.control_measures_id
		-- pollutant filter
		and er.pollutant_id = p.id
		-- min and max emission filter
		and ' || annualized_emis_sql || ' between coalesce(er.min_emis, -1E+308) and coalesce(er.max_emis, 1E+308)
--		and source_total.total_ann_emis between coalesce(er.min_emis, -1E+308) and coalesce(er.max_emis, 1E+308)
		-- locale filter
		and (er.locale = inv.fips or er.locale = substr(inv.fips, 1, 2) or er.locale = '''')
		-- effecive date filter
		and ' || inventory_year || '::integer >= coalesce(date_part(''year'', er.effective_date), ' || inventory_year || '::integer)

		-- target pollutant filter
--		left outer join emf.control_strategy_target_pollutants cstp
--		on cstp.pollutant_id = p.id
--		and cstp.control_strategy_id = ' || control_strategy_id || '

	where 	' || inv_filter || coalesce(county_dataset_filter_sql, '') || '
		and inv.fips like ' ||  quote_literal(strfipsst || '%') || '		
		-- constraint filter, BUT ONLY for target pollutants
		' || case when has_constraints then '
		and (	p.id <> ' ||  target_pollutant_id || ' --cstp.pollutant_id is null 
			or 
			(
				p.id == ' ||  target_pollutant_id || '-- cstp.pollutant_id is not null  
				and (
					' || percent_reduction_sql || ' >= ' || coalesce(min_control_efficiency_constraint, -100.0) || '
					' || coalesce(' and ' || percent_reduction_sql || ' / 100 * ' || annualized_emis_sql || ' >= ' || min_emis_reduction_constraint, '')  || '
					' || coalesce(' and coalesce(' || chained_gdp_adjustment_factor || ' * ' || get_strategt_cost_sql || '.computed_cost_per_ton, -1E+308) <= ' || max_cost_per_ton_constraint, '')  || '
					' || coalesce(' and coalesce(' || percent_reduction_sql || ' / 100 * ' || annualized_emis_sql || ' * ' || chained_gdp_adjustment_factor || ' * ' || get_strategt_cost_sql || '.computed_cost_per_ton, -1E+308) <= ' || max_ann_cost_constraint, '')  || '
				)
			)
		)' else '' end || '

	order by inv.fips, 
		inv.scc, 
		' || case when is_point_table = false then '' else 'inv.plantid, inv.pointid, inv.stackid, inv.segment, ' end || '
		er.pollutant_id, 
		case when length(er.locale) = 5 then 0 when length(er.locale) = 2 then 1 else 2 end, 
		' || percent_reduction_sql || ' desc, 
		' || get_strategt_cost_sql || '.computed_cost_per_ton';


	raise notice '%', 'end ' || strfipsst || ' ' || clock_timestamp();

END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.run_max_emis_red_strategy(control_strategy_id integer, input_dataset_id integer, 
	input_dataset_version integer, strategy_result_id int) RETURNS void AS $$
DECLARE
	inv_table_name varchar(63) := '';
	inv_filter varchar := '';
	inv_fips_filter text := '';
	detailed_result_dataset_id integer := null;
	detailed_result_table_name varchar(63) := '';
	county_dataset_id integer := null;
	county_dataset_version integer := null;
	region RECORD;
	target_pollutant_id integer := 0;
	measures_count integer := 0;
	measure_with_region_count integer := 0;
	measure_classes_count integer := 0;
	county_dataset_filter_sql text := '';
	cost_year integer := null;
	inventory_year integer := null;
	is_point_table boolean := false;
	use_cost_equations boolean := false;
	gimme_count integer := 0;
	min_emis_reduction_constraint real := null;
	min_control_efficiency_constraint real := null;
	max_cost_per_ton_constraint real := null;
	max_ann_cost_constraint real := null;
	has_constraints boolean := null;
	dataset_month smallint := 0;
	no_days_in_month smallint := 31;
	ref_cost_year integer := 2006;
	cost_year_chained_gdp double precision := null;
	ref_cost_year_chained_gdp double precision := null;
	chained_gdp_adjustment_factor double precision := null;
	discount_rate double precision;
BEGIN
	SET work_mem TO '512MB';
	SET enable_seqscan TO 'off';

	-- get the input dataset info
	select lower(i.table_name)
	from emf.internal_sources i
	where i.dataset_id = input_dataset_id
	into inv_table_name;

	-- get the detailed result dataset info
	select sr.detailed_result_dataset_id,
		lower(i.table_name)
	from emf.strategy_results sr
		inner join emf.internal_sources i
		on i.dataset_id = sr.detailed_result_dataset_id
	where sr.id = strategy_result_id
	into detailed_result_dataset_id,
		detailed_result_table_name;

	-- see if control strategy has only certain measures specified
	SELECT count(id), 
		count(case when region_dataset_id is not null then 1 else null end)
	FROM emf.control_strategy_measures 
	where control_strategy_measures.control_strategy_id = control_strategy_id 
	INTO measures_count, 
		measure_with_region_count;

	-- see if measure classes were specified
	IF measures_count = 0 THEN
		SELECT count(1)
		FROM emf.control_strategy_classes 
		where control_strategy_classes.control_strategy_id = control_strategy_id
		INTO measure_classes_count;
	END IF;

	-- get target pollutant, inv filter, and county dataset info if specified
	SELECT cs.pollutant_id,
		case when length(trim(cs.filter)) > 0 then '(' || cs.filter || ')' else null end,
		cs.cost_year,
		cs.analysis_year,
		cs.county_dataset_id,
		cs.county_dataset_version,
		cs.use_cost_equations,
		cs.discount_rate / 100
	FROM emf.control_strategies cs
	where cs.id = control_strategy_id
	INTO target_pollutant_id,
		inv_filter,
		cost_year,
		inventory_year,
		county_dataset_id,
		county_dataset_version,
		use_cost_equations,
		discount_rate;

	-- see if there are point specific columns to be indexed
	SELECT count(1) = 4
	FROM pg_class c
		inner join pg_attribute a
		on a.attrelid = c.oid
		inner join pg_type t
		on t.oid = a.atttypid
	WHERE c.relname = inv_table_name
		and a.attname in ('plantid','pointid','stackid','segment')
		AND a.attnum > 0
	into is_point_table;

	-- get strategy constraints
	SELECT max_emis_reduction,
		max_control_efficiency,
		min_cost_per_ton,
		min_ann_cost
	FROM emf.control_strategy_constraints csc
	where csc.control_strategy_id = control_strategy_id
	INTO min_emis_reduction_constraint,
		min_control_efficiency_constraint,
		max_cost_per_ton_constraint,
		max_ann_cost_constraint;

	select case when min_emis_reduction_constraint is not null 
		or min_control_efficiency_constraint is not null 
		or max_cost_per_ton_constraint is not null 
		or max_ann_cost_constraint is not null then true else false end
	into has_constraints;

	-- get month of the dataset, 0 (Zero) indicates an annual inventory
	select public.get_dataset_month(input_dataset_id)
	into dataset_month;

	IF dataset_month = 1 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 2 THEN
		no_days_in_month := 29;
	ELSIF dataset_month = 3 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 4 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 5 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 6 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 7 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 8 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 9 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 10 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 11 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 12 THEN
		no_days_in_month := 31;
	END IF;

	-- get gdp chained values
	SELECT cast(chained_gdp as double precision)
	FROM reference.gdplev
	where annual = cost_year
	INTO cost_year_chained_gdp;
	SELECT cast(chained_gdp as double precision)
	FROM reference.gdplev
	where annual = ref_cost_year
	INTO ref_cost_year_chained_gdp;

	chained_gdp_adjustment_factor := cost_year_chained_gdp / ref_cost_year_chained_gdp;

	-- if strategy have measures, then store these in a temp table for later use...
	IF measure_with_region_count > 0 THEN
		EXECUTE '
			CREATE TEMP TABLE measures (control_measure_id integer NOT NULL, region_id integer NOT NULL, region_version integer NOT NULL) ON COMMIT DROP;
			CREATE TEMP TABLE measure_regions (region_id integer NOT NULL, region_version integer NOT NULL, fips character varying(6) NOT NULL) ON COMMIT DROP;

--			CREATE TABLE measures (control_measure_id integer NOT NULL, region_id integer NOT NULL, region_version integer NOT NULL);
--			CREATE TABLE measure_regions (region_id integer NOT NULL, region_version integer NOT NULL, fips character varying(6) NOT NULL);

			CREATE INDEX measure_regions_measure_id ON measures USING btree (control_measure_id);
			CREATE INDEX measure_regions_region ON measures USING btree (region_id, region_version);
			CREATE INDEX regions_region ON measure_regions USING btree (region_id, region_version);
			CREATE INDEX regions_fips ON measure_regions USING btree (fips);';

		FOR region IN EXECUTE 
			'SELECT m.control_measure_id, i.table_name, m.region_dataset_id, m.region_dataset_version
			FROM emf.control_strategy_measures m
				inner join emf.internal_sources i
				on m.region_dataset_id = i.dataset_id
			where m.control_strategy_id = ' || control_strategy_id || '
				and m.region_dataset_id is not null'
		LOOP
			EXECUTE 'insert into measures (control_measure_id, region_id, region_version)
			SELECT ' || region.control_measure_id || ', ' || region.region_dataset_id || ', ' || region.region_dataset_version || ';';

			EXECUTE 'select count(1)
			from measure_regions
			where region_id = ' || region.region_dataset_id || '
				and region_version = ' || region.region_dataset_version || ''
			into gimme_count;

			IF gimme_count = 0 THEN
				EXECUTE 'insert into measure_regions (region_id, region_version, fips)
				SELECT ' || region.region_dataset_id || ', ' || region.region_dataset_version || ', fips
				FROM emissions.' || region.table_name || '
				where ' || public.build_version_where_filter(region.region_dataset_id, region.region_dataset_version);
			END IF;
		END LOOP;
	END IF;

	-- see if their was a county dataset specified for the strategy, is so then build a sql where clause filter for later use
	IF county_dataset_id is not null THEN
		county_dataset_filter_sql := ' and inv.fips in (SELECT fips
			FROM emissions.' || (SELECT table_name FROM emf.internal_sources where dataset_id = county_dataset_id) || '
			where ' || public.build_version_where_filter(county_dataset_id, county_dataset_version) || ')';
	END IF;
	-- build version info into where clause filter
	inv_filter := '(' || public.build_version_where_filter(input_dataset_id, input_dataset_version) || ')' || coalesce(' and ' || inv_filter, '');

	raise notice '%', 'start call_batch_state ' || clock_timestamp();

	execute 'select public.run_max_emis_red_strategy_by_state(' || control_strategy_id || '::integer, ' || input_dataset_id  || '::integer, 
		' || quote_literal(inv_table_name) || '::character varying, ' || quote_literal(inv_filter) || '::character varying, 
		' || detailed_result_dataset_id || '::integer, ' || quote_literal(detailed_result_table_name) || '::character varying, 
		fipsst::character varying, ' || measures_count || '::integer, 
		' || measure_with_region_count || '::integer, ' || measure_classes_count || '::integer, 
		' || target_pollutant_id || '::integer, ' || inventory_year || '::integer, 
		' || quote_literal(coalesce(county_dataset_filter_sql, '')) || '::text, ' || case when is_point_table then 'true' else 'false' end || '::boolean, 
		' || dataset_month || '::smallint, ' || no_days_in_month || '::smallint, 
		' || coalesce(min_emis_reduction_constraint || '', 'null') || '::real, ' || coalesce(min_control_efficiency_constraint || '', 'null') || '::real, 
		' || coalesce(max_cost_per_ton_constraint || '', 'null') || '::real, ' || coalesce(max_ann_cost_constraint || '', 'null') || '::real, 
		' || case when has_constraints then 'true' else 'false' end || '::boolean, ' || chained_gdp_adjustment_factor || '::double precision,
		' || case when use_cost_equations then 'true' else 'false' end || '::boolean, ' || discount_rate  || '::integer, 
		' || ref_cost_year_chained_gdp || '::double precision)
	from (
		SELECT DISTINCT ON (substring(fips, 1, 2)) substring(fips, 1, 2) as fipsst
		FROM emissions.' || inv_table_name || ' as inv
		where ' || inv_filter || county_dataset_filter_sql || '
		order by substring(fips, 1, 2) 
--		limit 1
	) fips';

	raise notice '%', 'end call_batch_state ' || clock_timestamp();

END;
$$ LANGUAGE plpgsql;

