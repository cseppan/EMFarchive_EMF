-- -------------CoST Tables--------------
-- emf.pollutants
CREATE TABLE emf.pollutants
(
  id SERIAL PRIMARY KEY,
  name varchar(255) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.pollutants OWNER TO emf;
CREATE INDEX pollutant_id
  ON emf.pollutants
  USING btree
  (id);
ALTER TABLE emf.pollutants CLUSTER ON pollutant_id;
-- emf.pollutants
--
-- emf.source_groups
CREATE TABLE emf.source_groups
(
  id SERIAL PRIMARY KEY,
  name varchar(255) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.source_groups OWNER TO emf;
CREATE INDEX source_groups_id
  ON emf.source_groups
  USING btree
  (id);
ALTER TABLE emf.source_groups CLUSTER ON source_groups_id;
CREATE INDEX source_groups_name
  ON emf.source_groups
  USING btree
  (name);
-- emf.source_groups
--

-- emf.control_measure_classes
CREATE TABLE emf.control_measure_classes
(
  id SERIAL PRIMARY KEY,
  name varchar(64) NOT NULL UNIQUE,
  description varchar(255)
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_classes OWNER TO emf;
CREATE INDEX control_measure_classes_id
  ON emf.control_measure_classes
  USING btree
  (id);
ALTER TABLE emf.control_measure_classes CLUSTER ON control_measure_classes_id;

-- emf.control_measure_classes

-- emf control_technologies
CREATE TABLE emf.control_technologies
(
  id SERIAL PRIMARY KEY,
  name varchar(128) UNIQUE NOT NULL,
  description text,
  lock_owner varchar(64),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.control_technologies OWNER TO emf;
CREATE INDEX control_technologies_id
  ON emf.control_technologies
  USING btree
  (id);
ALTER TABLE emf.control_technologies CLUSTER ON control_technologies_id;
CREATE INDEX control_technologies_name
  ON emf.control_technologies
  USING btree
  (name);
-- emf control_technologies

-- emf.control_measures
CREATE TABLE emf.control_measures
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  abbreviation varchar(10) NOT NULL UNIQUE,
  cm_class_id int4 REFERENCES emf.control_measure_classes(id),
  description text,
  device_code int4,
  equipment_life real,
  major_pollutant int4 REFERENCES emf.pollutants(id),
  control_technology int4 REFERENCES emf.control_technologies(id),
  source_group int4 REFERENCES emf.source_groups(id),
  data_souce varchar(128),
  creator int4  REFERENCES emf.users(id),
  cost_year int4,
  last_modified_time timestamp,
  lock_owner varchar(64),
  lock_date timestamp,
  date_reviewed timestamp,
  last_modified_by varchar(255) NOT NULL
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measures OWNER TO emf;
CREATE INDEX measure_id
  ON emf.control_measures
  USING btree
  (id);
ALTER TABLE emf.control_measures CLUSTER ON measure_id;
CREATE INDEX control_measures_control_technology
   ON emf.control_measures (control_technology);
CREATE INDEX control_measures_source_group
  ON emf.control_measures
  USING btree
  (source_group);
-- emf.control_measures


-- emf.control_measure_sccs
CREATE TABLE emf.control_measure_sccs
(
   id SERIAL PRIMARY KEY,
   control_measures_id  int4 NOT NULL REFERENCES emf.control_measures(id),
   name varchar(15),
   status varchar(255),
   UNIQUE(control_measures_id,name)
)
WITHOUT OIDS;
ALTER TABLE emf.control_measure_sccs OWNER TO emf;
CREATE INDEX measure_scc_measure_id
  ON emf.control_measure_sccs
  USING btree
  (control_measures_id);
CREATE INDEX measure_scc_scc
  ON emf.control_measure_sccs
  USING btree
  (name);
-- emf.control_measure_sccs

-- emf.control_measure_efficiencyrecords
CREATE TABLE emf.control_measure_efficiencyrecords
(
  id SERIAL PRIMARY KEY,
  control_measures_id int4 NOT NULL REFERENCES emf.control_measures(id),
  list_index int4,
  record_id int4,
  pollutant_id int4 NOT NULL REFERENCES emf.pollutants(id),
  existing_measure_abbr varchar(10),
  existing_dev_code int4,
  locale varchar(10),
  efficiency real,
  percent_reduction real,
  cost_year int4,
  cost_per_ton real,
  rule_effectiveness real,
  rule_penetration real,
  equation_type varchar(128),
  cap_rec_factor real,
  discount_rate real,
  detail text,
  effective_date timestamp,
  last_modified_by varchar(255) NOT NULL,
  last_modified_time timestamp NOT NULL,
  ref_yr_cost_per_ton float4,
  min_emis double precision,
  max_emis double precision,
  Cap_Ann_Ratio double precision,
  Incremental_Cost_Per_Ton double precision,
  UNIQUE (control_measures_id,pollutant_id,locale,existing_measure_abbr,effective_date, min_emis, max_emis)
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_efficiencyrecords OWNER TO emf;
CREATE INDEX effrec_min_max_emis
  ON emf.control_measure_efficiencyrecords
  USING btree
  (min_emis, max_emis);
CREATE INDEX er_locale
  ON emf.control_measure_efficiencyrecords
  USING btree
  (locale);
CREATE INDEX er_measureid
  ON emf.control_measure_efficiencyrecords
  USING btree
  (control_measures_id);
CREATE INDEX er_pollutantid
  ON emf.control_measure_efficiencyrecords
  USING btree
  (pollutant_id);  
-- emf.control_measure_efficiencyrecords

-- emf control_measure_sectors
CREATE TABLE emf.control_measure_sectors
(
  id SERIAL PRIMARY KEY,
  control_measure_id int4 NOT NULL REFERENCES emf.control_measures(id) ,
  list_index int4,
  sector_id int4 REFERENCES emf.sectors (id),
  UNIQUE (control_measure_id,sector_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_sectors OWNER TO emf;
CREATE INDEX control_measure_sectors_measure_id
  ON emf.control_measure_sectors
  USING btree
  (control_measure_id);  
CREATE INDEX control_measure_sectors_sector_id
  ON emf.control_measure_sectors
  USING btree
  (sector_id);  
-- emf control_measure_sectors

-- emf.strategy_types
CREATE TABLE emf.strategy_types
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  description text NOT NULL,
  default_sortorder text NULL DEFAULT '',
  strategy_classname varchar(255),
  lock_owner varchar(255),
  lock_date timestamp
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_types OWNER TO emf;
CREATE INDEX strategy_types_id
   ON emf.strategy_types (id);
ALTER TABLE emf.strategy_types CLUSTER ON strategy_types_id;
-- emf.strategy_types


-- emf.control_strategies
CREATE TABLE emf.control_strategies
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE,
  description text,
  run_status varchar(255),
  region_id int4 REFERENCES emf.regions(id),
  project_id int4 REFERENCES emf.projects (id),
  discount_rate real,
  total_cost real,
  reduction real,
  cost_year int4,
  analysis_year int4,
  creator_id int4 REFERENCES emf.users(id),
  last_modified_date timestamp,
  start_date timestamp,
  completion_date timestamp,
  strategy_type_id int4 REFERENCES emf.strategy_types(id),
  pollutant_id int4 REFERENCES emf.pollutants(id),
  filter varchar(255),
  lock_owner varchar(255),
  lock_date timestamp,
  county_file character varying,
  use_cost_equations boolean
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategies OWNER TO emf;
CREATE INDEX control_strategies_id
  ON emf.control_strategies
  USING btree
  (id);
ALTER TABLE emf.control_strategies CLUSTER ON control_strategies_id;
CREATE INDEX fki_strategy_county_dataset
  ON emf.control_strategies
  USING btree
  (county_dataset_id);
-- emf.control_strategies

-- emf.control_strategy_classes
CREATE TABLE emf.control_strategy_classes
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id) ,
  control_measure_class_id int4 REFERENCES emf.control_measure_classes (id),
  list_index int4,
  UNIQUE (control_strategy_id,control_measure_class_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_classes OWNER TO emf;
CREATE INDEX control_strategy_classes_measure_class_id
  ON emf.control_strategy_classes
  USING btree
  (control_measure_class_id);

CREATE INDEX control_strategy_classes_strategy_id
  ON emf.control_strategy_classes
  USING btree
  (control_strategy_id);
-- emf.control_strategy_classes

-- emf.control_strategy_measures
CREATE TABLE emf.control_strategy_measures
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id) ,
  control_measure_id int4 NOT NULL REFERENCES emf.control_measures (id),
  list_index int4 NOT NULL,
  include bool NOT NULL DEFAULT true,
  rule_effectiveness double precision,
  rule_penetration double precision,
  apply_order double precision,
  region_dataset_id integer,
  region_dataset_version integer,
  UNIQUE (control_strategy_id,control_measure_id) 
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_measures OWNER TO emf;
CREATE INDEX control_strategy_measures_apply_order
  ON emf.control_strategy_measures
  USING btree
  (apply_order);
CREATE INDEX control_strategy_strategy_id
  ON emf.control_strategy_measures
  USING btree
  (control_strategy_id);
CREATE INDEX control_strategy_measure_id
  ON emf.control_strategy_measures
  USING btree
  (control_measure_id);
-- emf.control_strategy_measures

-- emf.input_datasets_control_strategies
CREATE TABLE emf.input_datasets_control_strategies
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id),
  list_index int4,
  dataset_id int4 REFERENCES emf.datasets (id),
  dataset_version integer
) 
WITHOUT OIDS;
ALTER TABLE emf.input_datasets_control_strategies OWNER TO emf;
CREATE INDEX input_datasets_control_strategies_dataset_id
  ON emf.input_datasets_control_strategies
  USING btree
  (dataset_id);

CREATE INDEX input_datasets_control_strategies_strat_id
  ON emf.input_datasets_control_strategies
  USING btree
  (control_strategy_id);
-- emf.datasets_control_strategies

-- emf.strategy_result_types
CREATE TABLE emf.strategy_result_types
(
  id SERIAL PRIMARY KEY,
  name varchar(255) NOT NULL UNIQUE
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_result_types OWNER TO emf;
CREATE INDEX strategy_result_types_id
  ON emf.strategy_result_types
  USING btree
  (id);
ALTER TABLE emf.strategy_result_types CLUSTER ON strategy_result_types_id;
-- emf.strategy_result_types

-- emf.strategy_results
CREATE TABLE emf.strategy_results
(
  id SERIAL PRIMARY KEY,
  control_strategy_id int4 NOT NULL REFERENCES emf.control_strategies(id),
  dataset_id int4 NOT NULL REFERENCES emf.datasets(id),
  strategy_result_type_id int4 NOT NULL REFERENCES emf.strategy_result_types(id),
  detailed_result_dataset_id int4 REFERENCES emf.datasets(id),
  controlled_inven_dataset_id int4 REFERENCES emf.datasets(id),
  list_index int4,
  total_cost real,
  total_reduction real,
  start_time timestamp,
  completion_time timestamp,
  run_status VARCHAR(255),
  record_count integer,
  dataset_version integer NOT NULL DEFAULT 0,
  UNIQUE (control_strategy_id,dataset_id,detailed_result_dataset_id)
) 
WITHOUT OIDS;
ALTER TABLE emf.strategy_results OWNER TO emf;
CREATE INDEX strategy_results_strat_id
  ON emf.strategy_results
  USING btree
  (control_strategy_id);
-- emf.strategy_results

-- emf.aggregrated_efficiencyrecords
CREATE TABLE emf.aggregrated_efficiencyrecords
(
  control_measures_id integer NOT NULL,
  pollutant_id integer NOT NULL,
  max_efficiency real,
  min_efficiency real,
  avg_efficiency real,
  max_cost_per_ton real,
  min_cost_per_ton real,
  avg_cost_per_ton real,
  avg_rule_effectiveness real,
  avg_rule_penetration real,
  CONSTRAINT aggregrated_efficiencyrecords_pkey PRIMARY KEY (control_measures_id,pollutant_id),
  CONSTRAINT aggregrated_efficiencyrecords_control_measures_id_fkey FOREIGN KEY (control_measures_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT aggregrated_efficiencyrecords_pollutant_id_fkey FOREIGN KEY (pollutant_id)
      REFERENCES emf.pollutants (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.aggregrated_efficiencyrecords OWNER TO emf;
CREATE INDEX aggeffrec_measureid
  ON emf.aggregrated_efficiencyrecords
  USING btree
  (control_measures_id);
CREATE INDEX aggeffrec_pollid
  ON emf.aggregrated_efficiencyrecords
  USING btree
  (pollutant_id);

-- add new table control_strategy_constraints...
CREATE TABLE emf.control_strategy_constraints
(
  control_strategy_id integer NOT NULL,
  max_emis_reduction real,
  max_control_efficiency real,
  min_cost_per_ton real,
  min_ann_cost real,
  CONSTRAINT control_strategy_constraints_pkey PRIMARY KEY (control_strategy_id),
  CONSTRAINT control_strategy_constraints_control_strategy_id_fkey FOREIGN KEY (control_strategy_id)
      REFERENCES emf.control_strategies (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.control_strategy_constraints OWNER TO emf;

CREATE INDEX constraint_strategy_id
  ON emf.control_strategy_constraints
  USING btree
  (control_strategy_id);

CREATE TABLE emf.equation_types
(
  id serial NOT NULL,
  name character varying(255) NOT NULL,
  description text NOT NULL DEFAULT ''::text,
  CONSTRAINT equation_types_pkey PRIMARY KEY (id),
  CONSTRAINT equation_types_name_key UNIQUE (name)
) 
WITHOUT OIDS;
ALTER TABLE emf.equation_types OWNER TO emf;
CREATE INDEX equation_types_id
   ON emf.equation_types (id);
ALTER TABLE emf.equation_types CLUSTER ON equation_types_id;

CREATE TABLE emf.equation_type_variables
(
  id serial NOT NULL,
  equation_type_id integer NOT NULL,
  name character varying(255) NOT NULL,
  file_col_position smallint,
  description character varying(50) DEFAULT ''::character varying,
  list_index integer,
  CONSTRAINT equation_type_variables_pkey PRIMARY KEY (id),
  CONSTRAINT equation_type_variables_equation_type_id_fkey FOREIGN KEY (equation_type_id)
      REFERENCES emf.equation_types (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT equation_type_variables_id_key UNIQUE (id, equation_type_id)
) 
WITHOUT OIDS;
ALTER TABLE emf.equation_type_variables OWNER TO emf;
CREATE INDEX equation_type_variables_equation_type_id
  ON emf.equation_type_variables
  USING btree
  (equation_type_id);
CREATE INDEX equation_type_variables_id
  ON emf.equation_type_variables
  USING btree
  (id);
ALTER TABLE emf.equation_type_variables CLUSTER ON equation_type_variables_id;

CREATE TABLE emf.control_measure_equations
(
  id serial NOT NULL,
  control_measure_id integer NOT NULL,
  equation_type_id integer NOT NULL,
  equation_type_variable_id integer,
  value double precision,
  list_index integer NOT NULL,
  CONSTRAINT control_measure_equations_pkey PRIMARY KEY (id),
  CONSTRAINT control_measure_equations_control_measure_id_fkey FOREIGN KEY (control_measure_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_equations_equation_type_id_fkey FOREIGN KEY (equation_type_id, equation_type_variable_id)
      REFERENCES emf.equation_type_variables (equation_type_id, id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_equations_equation_type_id_fkey1 FOREIGN KEY (equation_type_id)
      REFERENCES emf.equation_types (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_equations OWNER TO emf;

CREATE INDEX fki_
  ON emf.control_measure_equations
  USING btree
  (equation_type_id, equation_type_variable_id);

CREATE INDEX fki_equation_measure
  ON emf.control_measure_equations
  USING btree
  (control_measure_id);

-- 9/12/2007 - DCD add user-defined functionm and aggreagte function to help build a comma-delimted list from a set
create function public.join_with_ampersand(text,text)
  returns text
  immutable strict language 'sql'
  as 'select $1||''&''||$2'
;
ALTER function public.join_with_ampersand(text,text) OWNER TO emf;

create aggregate public.concatenate_with_ampersand (
  sfunc = join_with_ampersand,
  basetype = text,
  stype = text
);
ALTER aggregate public.concatenate_with_ampersand(text) OWNER TO emf;

CREATE TABLE emf.control_measure_months
(
  id SERIAL PRIMARY KEY,
  control_measure_id integer NOT NULL,
  list_index integer,
  "month" smallint,
  CONSTRAINT control_measure_months_control_measure_id_fkey FOREIGN KEY (control_measure_id)
      REFERENCES emf.control_measures (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT control_measure_months_control_measure_id_key UNIQUE (control_measure_id, "month")
) 
WITHOUT OIDS;
ALTER TABLE emf.control_measure_months OWNER TO emf;

CREATE INDEX control_measure_months_measure_id
  ON emf.control_measure_months
  USING btree
  (control_measure_id);

CREATE INDEX control_measure_months_month
  ON emf.control_measure_months
  USING btree
  ("month");

CREATE OR REPLACE FUNCTION public.get_dataset_month(dataset_id integer) RETURNS smallint AS $$
DECLARE
	dataset_name varchar(255) := '';
	dataset_month smallint := 0;
	start_year smallint := null;
	start_month smallint := null;
	stop_year smallint := null;
	stop_month smallint := null;
BEGIN

	-- get the dataset information
	select lower(ds.name),
		EXTRACT(YEAR FROM ds.start_date_time),
		EXTRACT(MONTH FROM ds.start_date_time),
		EXTRACT(YEAR FROM ds.stop_date_time),
		EXTRACT(MONTH FROM ds.stop_date_time)
	from emf.datasets ds
	where ds.id = dataset_id
	into dataset_name,
		start_year,
		start_month,
		stop_year,
		stop_month;

	-- look at the start and stop time...
	IF start_month = stop_month and start_year = stop_year THEN
		dataset_month := start_month;
	-- look at the name to see if there is a date in it...
	ELSE
		IF position('jan' in dataset_name) > 0 or position('january' in dataset_name) > 0 THEN
			dataset_month := 1;
		ELSIF position('feb' in dataset_name) > 0 or position('february' in dataset_name) > 0 THEN
			dataset_month := 2;
		ELSIF position('mar' in dataset_name) > 0 or position('march' in dataset_name) > 0 THEN
			dataset_month := 3;
		ELSIF position('apr' in dataset_name) > 0 or position('april' in dataset_name) > 0 THEN
			dataset_month := 4;
		ELSIF position('may' in dataset_name) > 0 THEN
			dataset_month := 5;
		ELSIF position('jun' in dataset_name) > 0 or position('june' in dataset_name) > 0 THEN
			dataset_month := 6;
		ELSIF position('jul' in dataset_name) > 0 or position('july' in dataset_name) > 0 THEN
			dataset_month := 7;
		ELSIF position('aug' in dataset_name) > 0 or position('august' in dataset_name) > 0 THEN
			dataset_month := 8;
		ELSIF position('sep' in dataset_name) > 0 or position('september' in dataset_name) > 0 THEN
			dataset_month := 9;
		ELSIF position('oct' in dataset_name) > 0 or position('october' in dataset_name) > 0 THEN
			dataset_month := 10;
		ELSIF position('nov' in dataset_name) > 0 or position('november' in dataset_name) > 0 THEN
			dataset_month := 11;
		ELSIF position('dec' in dataset_name) > 0 or position('december' in dataset_name) > 0 THEN
			dataset_month := 12;
		END IF;
	END IF;

	-- return Zero if no month was found
	RETURN dataset_month;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.multiply(double precision, double precision)
  RETURNS double precision AS
'select $1 * $2'
  LANGUAGE 'sql' IMMUTABLE STRICT;
ALTER FUNCTION public.multiply(double precision, double precision) OWNER TO emf;

CREATE AGGREGATE public.times(
  BASETYPE=float8,
  SFUNC=multiply,
  STYPE=float8
);
ALTER AGGREGATE public.times(float8) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.create_strategy_detailed_result_table_indexes(table_name character varying)
  RETURNS void AS
$BODY$
DECLARE
	index_name varchar(63) := '';
BEGIN

	-- create source_id btree index
	IF length('source_id_' || table_name) >= 63 - 10 THEN
		index_name := 'source_id_' || substr(table_name, 11, 63);
	ELSE
		index_name := 'source_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(source_id)';

	-- create record_id btree index
	IF length('record_id' || table_name) >= 63 - 10 THEN
		index_name := 'record_id_' || substr(table_name, 11, 63);
	ELSE
		index_name := 'record_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(record_id)';

	-- create fips btree index
	IF length('fips_' || table_name) >= 63 - 5 THEN
		index_name := 'fips_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'fips_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(fips)';

	-- create scc btree index
	IF length('scc_' || table_name) >= 63 - 4 THEN
		index_name := 'scc_' || substr(table_name, 5, 63);
	ELSE
		index_name := 'scc_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(scc)';

	-- create plantid btree index
	IF length('plantid_' || table_name) >= 63 - 8 THEN
		index_name := 'plantid_' || substr(table_name, 9, 63);
	ELSE
		index_name := 'plantid_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(plantid)';

	-- create pointid btree index
	IF length('pointid_' || table_name) >= 63 - 8 THEN
		index_name := 'pointid_' || substr(table_name, 9, 63);
	ELSE
		index_name := 'pointid_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(pointid)';

	-- create stackid btree index
	IF length('stackid_' || table_name) >= 63 - 8 THEN
		index_name := 'stackid_' || substr(table_name, 9, 63);
	ELSE
		index_name := 'stackid_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(stackid)';

	-- create segment btree index
	IF length('segment_' || table_name) >= 63 - 8 THEN
		index_name := 'segment_' || substr(table_name, 9, 63);
	ELSE
		index_name := 'segment_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(segment)';

	-- create poll btree index
	IF length('poll_' || table_name) >= 63 - 5 THEN
		index_name := 'poll_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'poll_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(poll)';

	-- create cm_id btree index
	IF length('cm_id_' || table_name) >= 63 - 6 THEN
		index_name := 'cm_id_' || substr(table_name, 7, 63);
	ELSE
		index_name := 'cm_id_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(cm_id)';

END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION public.create_strategy_detailed_result_table_indexes(table_name character varying) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.create_orl_table_indexes(table_name character varying)
  RETURNS void AS
$BODY$
DECLARE
	index_name varchar(63) := '';
	is_point_table boolean := false;
BEGIN

	-- see if there are point specific columns to be indexed
	SELECT count(1) = 4
	FROM pg_class c
		inner join pg_attribute a
		on a.attrelid = c.oid
		inner join pg_type t
		on t.oid = a.atttypid
	WHERE c.relname = lower(table_name)
		and a.attname in ('plantid','pointid','stackid','segment')
		AND a.attnum > 0
	into is_point_table;

	-- Create Indexes....

	-- create fips btree index
	IF length('fips_' || table_name) >= 63 - 5 THEN
		index_name := 'fips_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'fips_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(fips)';

	-- create poll btree index
	IF length('poll_' || table_name) >= 63 - 5 THEN
		index_name := 'poll_' || substr(table_name, 6, 63);
	ELSE
		index_name := 'poll_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(poll)';

	-- create scc btree index
	IF length('scc_' || table_name) >= 63 - 4 THEN
		index_name := 'scc_' || substr(table_name, 5, 63);
	ELSE
		index_name := 'scc_' || table_name;
	END IF;
	execute 'CREATE INDEX ' || index_name || '
			ON emissions.' || table_name || '
			USING btree
			(scc)';

	-- add point specific indexes--plantid, pointid, stackid, segment
	IF is_point_table THEN
		-- create plantid btree index
		IF length('plantid_' || table_name) >= 63 - 8 THEN
			index_name := 'plantid_' || substr(table_name, 9, 63);
		ELSE
			index_name := 'plantid_' || table_name;
		END IF;
		execute 'CREATE INDEX ' || index_name || '
				ON emissions.' || table_name || '
				USING btree
				(plantid)';

		-- create pointid btree index
		IF length('pointid_' || table_name) >= 63 - 8 THEN
			index_name := 'pointid_' || substr(table_name, 9, 63);
		ELSE
			index_name := 'pointid_' || table_name;
		END IF;
		execute 'CREATE INDEX ' || index_name || '
				ON emissions.' || table_name || '
				USING btree
				(pointid)';

		-- create stackid btree index
		IF length('stackid_' || table_name) >= 63 - 8 THEN
			index_name := 'stackid_' || substr(table_name, 9, 63);
		ELSE
			index_name := 'stackid_' || table_name;
		END IF;
		execute 'CREATE INDEX ' || index_name || '
				ON emissions.' || table_name || '
				USING btree
				(stackid)';

		-- create segment btree index
		IF length('segment_' || table_name) >= 63 - 8 THEN
			index_name := 'segment_' || substr(table_name, 9, 63);
		ELSE
			index_name := 'segment_' || table_name;
		END IF;
		execute 'CREATE INDEX ' || index_name || '
				ON emissions.' || table_name || '
				USING btree
				(segment)';
	END IF;

END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION public.create_orl_table_indexes(table_name character varying) OWNER TO emf;

CREATE OR REPLACE FUNCTION public.build_version_where_filter(dataset_id integer, version integer)
  RETURNS text AS
$BODY$
DECLARE
	path text := '';
	versions_path text := '';
	where_filter text := '';
	delete_filter text := '';
	counter integer := 1;
	version_part text := '';
BEGIN

	--get version path
	select versions.path
	from emissions.versions
	where versions.dataset_id = dataset_id
		and versions.version = version
	into path;

	-- build path into where clause
	IF path is null or length(path) = 0 THEN
		versions_path := version;
	ELSE
		versions_path := path || ',' || version;
	END IF;
	where_filter := 'version IN (' || versions_path || ') and dataset_id = ' || dataset_id;

	version_part := split_part(versions_path, ',', counter);
	WHILE length(version_part) > 0 LOOP
		IF version_part != '0' THEN
			IF length(delete_filter) > 0 THEN
				delete_filter := delete_filter || ' and delete_versions NOT SIMILAR TO ''' || '(' || version_part || '|' || version_part || ',%|%,' || version_part || ',%|%,' || version_part || ')''';
			ELSE
				delete_filter := delete_filter || 'delete_versions NOT SIMILAR TO ''' || '(' || version_part || '|' || version_part || ',%|%,' || version_part || ',%|%,' || version_part || ')''';
			END IF;
		END IF;
		counter := counter + 1;
		version_part := split_part(versions_path, ',', counter);
	END LOOP;
	IF length(delete_filter) > 0 THEN
		where_filter := where_filter || ' and ' || delete_filter;
	END IF;

	RETURN where_filter;
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION public.build_version_where_filter(dataset_id integer, version integer) OWNER TO postgres;

CREATE OR REPLACE FUNCTION public.run_apply_measures_in_series_strategy_batch_by_state(control_strategy_id integer, input_dataset_id integer, 
	inv_table_name varchar(63), inv_filter varchar, 
	detailed_result_dataset_id integer, detailed_result_table_name varchar(63), 
	strfipsst varchar(2), measures_count integer, 
	measure_classes_count integer, target_pollutant_id integer,
	measure_with_region_count integer, county_dataset_filter_sql text,
	min_emis_reduction_constraint real, min_control_efficiency_constraint real,
	max_cost_per_ton_constraint real, max_ann_cost_constraint real) RETURNS integer AS $$
DECLARE
	dataset_month smallint := 0;
	no_days_in_month smallint := 31;
	has_constraints boolean := false;
BEGIN
	SET enable_seqscan TO 'off';
	SET work_mem TO '512MB';
--	SET enable_nestloop TO 'off';

	-- get month of the dataset, 0 (Zero) indicates an annual inventory
	select public.get_dataset_month(input_dataset_id)
	into dataset_month;

	IF dataset_month = 1 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 2 THEN
		no_days_in_month := 29;
	ELSIF dataset_month = 3 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 4 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 5 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 6 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 7 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 8 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 9 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 10 THEN
		no_days_in_month := 31;
	ELSIF dataset_month = 11 THEN
		no_days_in_month := 30;
	ELSIF dataset_month = 12 THEN
		no_days_in_month := 31;
	END IF;

	raise notice '%', 'start ' || strfipsst || ' ' || clock_timestamp();

	EXECUTE 'insert into emissions.' || detailed_result_table_name || ' 
		(
		dataset_id,
		cm_abbrev,
		poll,
		scc,
		fips,
		annual_cost,
		ann_cost_per_ton,
		control_eff,
		rule_pen,
		rule_eff,
		percent_reduction,
		final_emissions,
		emis_reduction,
		inv_emissions,
		fipsst,
		fipscty,
		source_id,
		input_ds_id,
		cs_id,
		cm_id
		)
	select 	' || detailed_result_dataset_id || '::integer,
		abbreviation,
		poll,
		scc,
		fips,
		ann_cost,
		ref_yr_cost_per_ton,
		efficiency,
		rule_pen,
		rule_eff,
		percent_reduction,
		final_emissions,
		emis_reduction,
		inv_emissions,
		fipsst,
		fipscty,
		source_id,
		' || input_dataset_id || '::integer,
		' || control_strategy_id || '::integer,
		cm_id
	from (
		select DISTINCT ON (inv.scc, inv.fips, er.pollutant_id, er.control_measures_id) 
			m.abbreviation,
			inv.poll,
			inv.scc,
			inv.fips,
			ref_yr_cost_per_ton * coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis) * efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100 / 100 as ann_cost,
			ref_yr_cost_per_ton,
			efficiency,
			' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' as rule_pen,
			' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' as rule_eff,
			efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100 as percent_reduction,
			' || case when dataset_month != 0 then 'coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis)' else 'inv.ann_emis' end || ' * (1 - efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100 / 100) as final_emissions,
			' || case when dataset_month != 0 then 'coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis)' else 'inv.ann_emis' end || ' * efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' / 100 / 100 / 100 as emis_reduction,
			' || case when dataset_month != 0 then 'coalesce(inv.avd_emis * ' || no_days_in_month || ', inv.ann_emis)' else 'inv.ann_emis' end || ' as inv_emissions,
			substr(inv.fips, 1, 2) as fipsst,
			substr(inv.fips, 3, 3) as fipscty,
			inv.record_id::integer as source_id,
			er.control_measures_id as cm_id,
			' || case when measures_count > 0 then 'csm.apply_order ' else '1.0' end || ' as apply_order
		FROM emissions.' || inv_table_name || ' inv

			inner join emf.pollutants p
			on p.name = inv.poll

			inner join emf.control_measure_sccs scc
			on scc.name = inv.scc

			' || case when measures_count > 0 then '
			inner join emf.control_strategy_measures csm
			on csm.control_measure_id = scc.control_measures_id
			' else '' end || '

			' || case when measure_with_region_count > 0 and 1 = 0 then '
			left outer join measure_region mr
			on mr.control_measure_id = scc.control_measures_id
			and mr.fips = inv.fips
			' else '' end || '

			inner join emf.control_measures m
			on m.id = scc.control_measures_id

			inner join emf.control_measure_months ms
			on ms.control_measure_id = m.id
			and ms.month in (0' || case when dataset_month != 0 then ',' || dataset_month else '' end || ')

			inner join emf.control_measure_efficiencyrecords er
			on er.control_measures_id = scc.control_measures_id
			-- pollutant filter
			and er.pollutant_id = p.id
			-- min and max emission filter
			and ' || case when dataset_month != 0 then 'coalesce(inv.avd_emis * 365, inv.ann_emis)' else 'inv.ann_emis' end || ' between coalesce(er.min_emis, -1E+308) and coalesce(er.max_emis, 1E+308)
			-- locale filter
			and (er.locale = inv.fips or er.locale = substr(inv.fips, 1, 2) or er.locale = '''')
			-- effecive date filter
			and 2020::integer >= coalesce(date_part(''year'', er.effective_date), 2020::integer)

			' || case when measures_count = 0 and measure_classes_count > 0 then '
			inner join emf.control_strategy_classes csc
			on csc.control_measure_class_id = m.cm_class_id
			and csc.control_strategy_id = ' || control_strategy_id || '
			' else '' end || '

		where 	' || inv_filter || coalesce(county_dataset_filter_sql, '') || '
			and inv.fips like ' ||  quote_literal(strfipsst || '%') || '
			' || case when measures_count > 0 then '
			and csm.control_strategy_id = ' || control_strategy_id || '
			' else '' end || '
			' || case when measure_with_region_count > 0 and 1 = 0 then '
			and (
				(mr.control_measure_id is not null and mr.fips = inv.fips) 
				or (mr.control_measure_id is null)
			)' else '' end || '

		order by inv.scc, inv.fips, er.pollutant_id, er.control_measures_id, case when length(locale) = 5 then 0 when length(locale) = 2 then 1 else 2 end, ref_yr_cost_per_ton, efficiency * ' || case when measures_count > 0 then 'coalesce(csm.rule_effectiveness, er.rule_effectiveness)' else 'er.rule_effectiveness' end || ' * ' || case when measures_count > 0 then 'coalesce(csm.rule_penetration, er.rule_penetration)' else 'er.rule_penetration' end || ' desc) as tbl
	order by scc, fips, poll, apply_order, coalesce(ref_yr_cost_per_ton, 0), percent_reduction desc';
	
	raise notice '%', 'end ' || strfipsst || ' ' || clock_timestamp();

	RETURN 1;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION public.run_apply_measures_in_series_strategy(control_strategy_id integer, input_dataset_id integer, 
	input_dataset_version integer, strategy_result_id int) RETURNS integer AS $$
DECLARE
--	control_strategy_id integer := null;
--	input_dataset_id integer := null;
--	input_dataset_version integer := null;
	inv_table_name varchar(63) := '';
	inv_filter varchar := '';
	inv_fips_filter text := '';
	detailed_result_dataset_id integer := null;
	detailed_result_table_name varchar(63) := '';
	county_dataset_id integer := null;
	county_dataset_version integer := null;
	region RECORD;
	target_pollutant_id integer := 0;
	target_pollutant varchar(255) := '';
	measure_with_region_count integer := 0;
	measures_count integer := 0;
	measure_classes_count integer := 0;
	min_emis_reduction_constraint real := null;
	min_control_efficiency_constraint real := null;
	max_cost_per_ton_constraint real := null;
	max_ann_cost_constraint real := null;
	has_constraints boolean := null;
	county_dataset_filter_sql text := '';
	cost_year integer := null;
	ref_cost_year integer := 2006;
	cost_year_chained_gdp double precision := null;
	ref_cost_year_chained_gdp double precision := null;
BEGIN
	SET work_mem TO '512MB';
	SET enable_seqscan TO 'off';

	-- get the input dataset info
	select i.table_name
	from emf.internal_sources i
	where i.dataset_id = input_dataset_id
	into inv_table_name;

	-- get the detailed result dataset info
	select sr.detailed_result_dataset_id,
		i.table_name
	from emf.strategy_results sr
		inner join emf.internal_sources i
		on i.dataset_id = sr.detailed_result_dataset_id
	where sr.id = strategy_result_id
	into detailed_result_dataset_id,
		detailed_result_table_name;

	-- see if control strategy has only certain measures specified
	SELECT count(id), 
		count(case when region_dataset_id is not null then 1 else null end)
	FROM emf.control_strategy_measures 
	where control_strategy_measures.control_strategy_id = control_strategy_id 
	INTO measures_count, 
		measure_with_region_count;

	-- see if measure classes were specified
	IF measures_count = 0 THEN
		SELECT count(1)
		FROM emf.control_strategy_classes 
		where control_strategy_classes.control_strategy_id = control_strategy_id
		INTO measure_classes_count;
	END IF;

	-- get target pollutant, inv filter, and county dataset info if specified
	SELECT cs.pollutant_id,
		case when length(trim(cs.filter)) > 0 then '(' || cs.filter || ')' else null end,
		cs.cost_year,
		cs.county_dataset_id,
		cs.county_dataset_version
	FROM emf.control_strategies cs
	where cs.id = control_strategy_id
	INTO target_pollutant_id,
		inv_filter,
		cost_year,
		county_dataset_id,
		county_dataset_version;
	
	select p.name
	FROM emf.pollutants p
	where p.id = target_pollutant_id
	INTO target_pollutant;

	-- get gdp chained values
	SELECT cast(chained_gdp as double precision)
	FROM reference.gdplev
	where annual = cost_year
	INTO cost_year_chained_gdp;
	SELECT cast(chained_gdp as double precision)
	FROM reference.gdplev
	where annual = ref_cost_year
	INTO ref_cost_year_chained_gdp;

	-- get strategy constraints
	SELECT max_emis_reduction,
		max_control_efficiency,
		min_cost_per_ton,
		min_ann_cost
	FROM emf.control_strategy_constraints csc
	where csc.control_strategy_id = control_strategy_id
	INTO min_emis_reduction_constraint,
		min_control_efficiency_constraint,
		max_cost_per_ton_constraint,
		max_ann_cost_constraint;

	select case when min_emis_reduction_constraint is not null 
		or min_control_efficiency_constraint is not null 
		or max_cost_per_ton_constraint is not null 
		or max_ann_cost_constraint is not null then true else false end
	into has_constraints;

	-- see if their was a county dataset specified for the strategy, is so then build a sql where clause filter for later use
	IF county_dataset_id is not null THEN
		county_dataset_filter_sql := ' and fips in (SELECT fips
			FROM emissions.' || (SELECT table_name FROM emf.internal_sources where dataset_id = county_dataset_id) || '
			where ' || public.build_version_where_filter(county_dataset_id, county_dataset_version) || ')';
/*
		FOR region IN EXECUTE 
			'SELECT fips
			FROM emissions.' || (SELECT table_name FROM emf.internal_sources where dataset_id = county_dataset_id) || '
			where ' || public.build_version_where_filter(county_dataset_id, county_dataset_version)
		LOOP
			IF length(inv_fips_filter) > 0 THEN
				inv_fips_filter := inv_fips_filter || ',' || quote_literal(region.fips);
			ELSE
				inv_fips_filter := inv_fips_filter || quote_literal(region.fips);
			END IF;
		END LOOP;
		IF length(inv_fips_filter) > 0 THEN 
			inv_filter := coalesce(inv_filter || ' and ', '') || 'fips in (' || inv_fips_filter || ')';
		END IF;
*/
	END IF;
	-- build version info into where clause filter
	inv_filter := '(' || public.build_version_where_filter(input_dataset_id, input_dataset_version) || ')' || coalesce(' and ' || inv_filter, '');

--	raise notice '%', 'inv_filter ' || inv_filter || clock_timestamp();

	-- if strategy have measures, then store these in a temp table for later use...
	IF measure_with_region_count > 0 THEN
		EXECUTE 'CREATE TEMP TABLE measure_region (control_measure_id integer NOT NULL, fips character varying(6) NOT NULL) ON COMMIT DROP;
--			CREATE INDEX measure_region_cl ON measure_region USING btree (control_measure_id, fips);
--			ALTER TABLE measure_region CLUSTER ON measure_region_cl;
			CREATE INDEX measure_region_measure_id ON measure_region USING btree (control_measure_id);
			CREATE INDEX measure_region_fips ON measure_region USING btree (fips);';

		FOR region IN EXECUTE 
			'SELECT m.control_measure_id, i.table_name, m.region_dataset_id, m.region_dataset_version
			FROM emf.control_strategy_measures m
				inner join emf.internal_sources i
				on m.region_dataset_id = i.dataset_id
			where m.control_strategy_id = ' || control_strategy_id || '
				and m.region_dataset_id is not null'
		LOOP
			EXECUTE 'insert into measure_region (control_measure_id, fips)
			SELECT ' || region.control_measure_id || ', fips
			FROM emissions.' || region.table_name || '
			where ' || public.build_version_where_filter(region.region_dataset_id, region.region_dataset_version);
		END LOOP;

	END IF;

	raise notice '%', 'start call_batch_state ' || clock_timestamp();

--	raise notice '%', 'inv_filter ' || inv_filter;
--	raise notice '%', 'county_dataset_filter_sql ' || county_dataset_filter_sql;

	execute 'select public.run_apply_measures_in_series_strategy_batch_by_state(' || control_strategy_id || ', ' || input_dataset_id  || ', 
		' || quote_literal(inv_table_name) || ', ' || quote_literal(inv_filter) || ', 
		' || detailed_result_dataset_id || ', ' || quote_literal(detailed_result_table_name) || ', 
		fipsst, ' || measures_count || ', 
		' || measure_classes_count || ', ' || target_pollutant_id || ', 
		' || measure_with_region_count || ', ' || quote_literal(coalesce(county_dataset_filter_sql, '')) || ',
		' || coalesce(min_emis_reduction_constraint || '', 'null') || ', ' || coalesce(min_control_efficiency_constraint || '', 'null') || ', 
		' || coalesce(max_cost_per_ton_constraint || '', 'null') || ', ' || coalesce(max_ann_cost_constraint || '', 'null') || ')
	from (
		SELECT DISTINCT ON (substring(fips, 1, 2)) substring(fips, 1, 2) as fipsst
		FROM emissions.' || inv_table_name || ' as inv
		where ' || inv_filter || county_dataset_filter_sql || '
		order by substring(fips, 1, 2) 
--		limit 1
	) fips';

	-- get rid of sources that use measures not in there county, this is post step becuase using a join during the measure selection process seem to be slower.
	IF measure_with_region_count > 0 THEN
--		execute 'raise notice ''%'', ''get rid of sources that use measures not in there county - before count '' || (select count(1) from emissions.' || detailed_result_table_name || ') || '' '' || clock_timestamp();';
--		raise notice '%', 'get rid of sources that use measures not in there county - before count ' || (select count(1) from emissions.csdr_test5) || ' ' || clock_timestamp();

/*		EXECUTE	'delete from only emissions.' || detailed_result_table_name || '
				where record_id in (
					select record_id
					from emissions.' || detailed_result_table_name || ' as inv
						inner join emf.control_strategy_measures csm
						on csm.control_measure_id = inv.cm_id
						and csm.region_dataset_id is not null
						left outer join measure_region mr
						on mr.control_measure_id = inv.cm_id
						and mr.fips = inv.fips
					where mr.fips is null
						and csm.control_strategy_id = ' || control_strategy_id || ')
		';
*/
		EXECUTE	'delete from only emissions.' || detailed_result_table_name || ' as inv2
			where	not exists (select 1
					from measure_region mr
					where mr.control_measure_id = inv2.cm_id
						and mr.fips = inv2.fips
					)

				and exists (select 1 
					from emf.control_strategy_measures csm
					where csm.control_strategy_id = ' || control_strategy_id || '
						and csm.control_measure_id = inv2.cm_id
						and csm.region_dataset_id is not null
					)

		';
--		raise notice '%', 'after count ' || (select count(1) from emissions.csdr_test5) || ' ' || clock_timestamp();
	END IF;

--	SET enable_seqscan TO 'on';
--	execute 'raise notice ''%'', ''readjust detailed result - count '' || (select count(1) from emissions.' || detailed_result_table_name || ') || '' '' || clock_timestamp();';

	-- update the detailed result
/*raise notice '%', 
	'update emissions.' || detailed_result_table_name || ' as inv
	set 	inv_emissions = case when (select min(inv2.record_id) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) = inv.record_id then inv.inv_emissions else null end,
		final_emissions = case when (select max(inv2.record_id) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) = inv.record_id then inv.inv_emissions * (select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) else null end,
		emis_reduction = inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		annual_cost = inv.ann_cost_per_ton * inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		apply_order = (select count(1) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id <= inv.record_id)';
*/
	EXECUTE	'update emissions.' || detailed_result_table_name || ' as inv
	set 	emis_reduction = inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		annual_cost = ' || cost_year_chained_gdp || ' / ' || ref_cost_year_chained_gdp || ' * inv.ann_cost_per_ton * inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		apply_order = (select count(1) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id <= inv.record_id),
		input_emis = inv.inv_emissions * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		output_emis = inv.inv_emissions * (1 - inv.percent_reduction / 100) * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		final_emissions = null,
		ann_cost_per_ton = ' || cost_year_chained_gdp || ' / ' || ref_cost_year_chained_gdp || ' * ann_cost_per_ton';

	-- make sure we meet the constraints, if not get rid of the applicable measures...
	IF has_constraints THEN
--		raise notice '%', 'get rid of sources that use measures not in there county - before count ' || (select count(1) from emissions.csdr_test5) || ' ' || clock_timestamp();
/*		execute 'create table emissions.noconstraints as 
			select scc, fips, cm_id, inv2.percent_reduction, inv2.poll, inv2.emis_reduction, inv2.ann_cost_per_ton, inv2.annual_cost
			from emissions.' || detailed_result_table_name || ' as inv2
			where inv2.poll = ' || quote_literal(target_pollutant) || '';
		execute 'create table emissions.constraints as 
			select scc, fips, cm_id, inv2.percent_reduction, inv2.poll, inv2.emis_reduction, inv2.ann_cost_per_ton, inv2.annual_cost
			from emissions.' || detailed_result_table_name || ' as inv2
			where inv2.poll = ' || quote_literal(target_pollutant) || '
				and (
					inv2.percent_reduction < ' || coalesce(min_control_efficiency_constraint, -100.0) || '
					' || coalesce(' or inv2.emis_reduction < ' || min_emis_reduction_constraint, '')  || '
					' || coalesce(' or inv2.ann_cost_per_ton > ' || max_cost_per_ton_constraint, '')  || '
					' || coalesce(' or inv2.annual_cost > ' || max_ann_cost_constraint, '')  || '
				)';
*/
		execute 'delete from emissions.' || detailed_result_table_name || ' as inv
			using emissions.' || detailed_result_table_name || ' as inv2
			where not exists (select 1 
				from emissions.' || detailed_result_table_name || ' as inv2
				where inv2.scc = inv.scc
				and inv2.fips = inv.fips
				and inv2.cm_id = inv.cm_id
				and inv2.poll = ' || quote_literal(target_pollutant) || '
				and (
					inv2.percent_reduction > ' || coalesce(min_control_efficiency_constraint, -100.0) || '
					' || coalesce(' and inv2.emis_reduction > ' || min_emis_reduction_constraint, '')  || '
					' || coalesce(' and coalesce(inv2.ann_cost_per_ton, -1E+308) < ' || max_cost_per_ton_constraint, '')  || '
					' || coalesce(' and coalesce(inv2.annual_cost, -1E+308) < ' || max_ann_cost_constraint, '')  || '
				))
				and exists (select 1 
					from emissions.' || detailed_result_table_name || ' as inv3
					where inv3.fips = inv.fips
						and inv3.scc = inv.scc
						and inv3.poll = ' || quote_literal(target_pollutant) || '
					)
				';
		-- update the apply order again, there are bound to be gaps...
		EXECUTE	'update emissions.' || detailed_result_table_name || ' as inv
		set 	apply_order = (select count(1) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id <= inv.record_id)';

	END IF;

/*	'inv_emissions = case when (select min(inv2.record_id) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) = inv.record_id then inv.inv_emissions else null end,
		final_emissions = case when (select max(inv2.record_id) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) = inv.record_id then inv.inv_emissions * (select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id) else null end,
		emis_reduction = inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		annual_cost = inv.ann_cost_per_ton * inv.inv_emissions * inv.percent_reduction / 100 * coalesce((select public.times(1 - inv2.percent_reduction / 100) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id < inv.record_id), 1),
		apply_order = (select count(1) from emissions.' || detailed_result_table_name || ' as inv2 where inv2.source_id = inv.source_id and inv2.record_id <= inv.record_id)';
*/
	EXECUTE	'update emissions.' || detailed_result_table_name || ' as inv
	set 	inv_emissions = null 
	where apply_order > 1';

	EXECUTE	'update emissions.' || detailed_result_table_name || ' as inv
	set 	final_emissions = (select min(output_emis) from emissions.' || detailed_result_table_name || ' where source_id = inv.source_id)
	where apply_order = 1 ';

	raise notice '%', 'end call_batch_state ' || clock_timestamp();

	RETURN 1;
END;
$$ LANGUAGE plpgsql;